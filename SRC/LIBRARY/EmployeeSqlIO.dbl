;;*****************************************************************************
;;
;; File:        EmployeeSqlIO.dbl
;;
;; Description: Various functions that performs SQL I/O for EMPLOYEE
;;
;;*****************************************************************************
;; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;;*****************************************************************************

import ReplicationLibrary

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

;;*****************************************************************************
;;; <summary>
;;; Determines if the Employee table exists in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function EmployeeExists, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        error       ,int    ;;Returned error number
        dberror     ,int    ;;Database error number
        cursor      ,int    ;;Database cursor
        length      ,int    ;;Length of a string
        table_name  ,a128   ;;Retrieved table name
        errtxt      ,a512   ;;Error message text
    endrecord

proc

    init local_data

    ;;Open a cursor for the SELECT statement

    if (%ssc_open(a_dbchn,cursor,"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'",SSQL_SELECT)==SSQL_FAILURE)
    begin
        error=-1
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    ;;Bind host variables to receive the data

    if (!error)
    begin
        if (%ssc_define(a_dbchn,cursor,1,table_name)==SSQL_FAILURE)
        begin
            error=-1
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variable"
        end
    end

    ;;Move data to host variables

    if (!error)
    begin
        if (%ssc_move(a_dbchn,cursor,1)==SSQL_NORMAL)
                error = 1 ;; Table exists
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (!error)
            begin
                error=-1
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (error) then
            a_errtxt = errtxt
        else
            a_errtxt = ""
    end

    freturn error

endfunction

;;*****************************************************************************
;;; <summary>
;;; Creates the Employee table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeCreate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Create the database table and primary key constraint

    if (ok)
    begin
        sql = 'CREATE TABLE "Employee" ('
        & + '"EmpId" DECIMAL(6) NOT NULL,'
        & + '"EmpFirstName" VARCHAR(20) NOT NULL,'
        & + '"EmpLastName" VARCHAR(20) NOT NULL,'
        & + '"EmpDept" VARCHAR(15) NOT NULL,'
        & + '"EmpHireDate" DATE,'
        & + '"EmpPhoneWork" VARCHAR(14),'
        & + '"EmpPhoneHome" VARCHAR(14),'
        & + '"EmpPhoneCell" VARCHAR(14),'
        & + '"EmpPaid" DECIMAL(1),'
        & + '"EmpHomeOk" DECIMAL(1),'
        & + '"EmpDateOfBirth" DATE,'
        & + '"EmpHireTime" TIME(0),'
        & + '"EmpEmail" VARCHAR(40),'
        & + '"EmpAddressStreet" VARCHAR(30),'
        & + '"EmpAddressCity" VARCHAR(20),'
        & + '"EmpAddressState" VARCHAR(2),'
        & + '"EmpAddressZip" DECIMAL(5),'
        & + 'CONSTRAINT PK_Employee PRIMARY KEY CLUSTERED("EmpId" ASC)'
        & + ')'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Grant access permissions

    if (ok)
    begin
        sql = 'GRANT ALL ON "Employee" TO PUBLIC'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Employee table if they do not exist.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    optional in  a_logchannel, n
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok                  ,boolean    ;;Return status
        dberror             ,int        ;;Database error number
        cursor              ,int        ;;Database cursor
        length              ,int        ;;Length of a string
        transaction         ,int        ;;Transaction in process
        keycount            ,int        ;;Total number of keys
        errtxt              ,a512       ;;Returned error message text
        now                 ,a20        ;;Current date and time
        sql                 ,string     ;;SQL statement
    endrecord

    .define writelog(x) writes(a_logchannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

proc
    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Set the SQL statement execution timeout to the bulk load value

    if (ok)
    begin
        now = %datetime
        writelog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to set database timeout"
        end
    end

    ;;Create index 1 (Department ID)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_EmpDept",errtxt))
    begin
        now = %datetime
        writelog("  - Adding index IX_Employee_EmpDept")

        sql = 'CREATE  INDEX IX_Employee_EmpDept ON "Employee"("EmpDept" ASC)'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Create index 2 (Last name)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_EmpLastName",errtxt))
    begin
        now = %datetime
        writelog("  - Adding index IX_Employee_EmpLastName")

        sql = 'CREATE  INDEX IX_Employee_EmpLastName ON "Employee"("EmpLastName" ASC)'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Create index 3 (State)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_StateCode",errtxt))
    begin
        now = %datetime
        writelog("  - Adding index IX_Employee_StateCode")

        sql = 'CREATE  INDEX IX_Employee_StateCode ON "Employee"("EmpAddressState" ASC)'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Create index 4 (Zip code)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_ZipCode",errtxt))
    begin
        now = %datetime
        writelog("  - Adding index IX_Employee_ZipCode")

        sql = 'CREATE  INDEX IX_Employee_ZipCode ON "Employee"("EmpAddressZip" ASC)'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end


    ;;Set the database timeout back to the regular value

    now = %datetime
    writelog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
    if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
        nop

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Employee table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeUnIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        keycount    ,int        ;;Total number of keys
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc
    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Drop index 1 (Department ID)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_EmpDept ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Drop index 2 (Last name)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_EmpLastName ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Drop index 3 (State)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_StateCode ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Drop index 4 (Zip code)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_ZipCode ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Insert a row into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function EmployeeInsert, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        sts         ,int        ;;Return status
        dberror     ,int        ;;Database error number
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Employee ("
        & +              '"EmpId",'
        & +              '"EmpFirstName",'
        & +              '"EmpLastName",'
        & +              '"EmpDept",'
        & +              '"EmpHireDate",'
        & +              '"EmpPhoneWork",'
        & +              '"EmpPhoneHome",'
        & +              '"EmpPhoneCell",'
        & +              '"EmpPaid",'
        & +              '"EmpHomeOk",'
        & +              '"EmpDateOfBirth",'
        & +              '"EmpHireTime",'
        & +              '"EmpEmail",'
        & +              '"EmpAddressStreet",'
        & +              '"EmpAddressCity",'
        & +              '"EmpAddressState",'
        & +              '"EmpAddressZip"'
        & +              ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15,:16,:17)"
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;;Storage for HH:MM time field
    endrecord

    global common
        csr_employee_insert1, i4, 0
    endcommon

proc

    init local_data
    ok = true
    sts = 1
    openAndBind = (csr_employee_insert1 == 0)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_employee_insert1,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_employee_insert1,17,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_home,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    employee.emp_home_ok,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the row into the database

    if (ok)
    begin
        ;;Load the data into the bound record

        employee = a_data

        ;;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_home = %atrim(employee.emp_phone_home)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsNumeric(^a(employee.emp_id))))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsNumeric(^a(employee.emp_paid))))
            clear employee.emp_paid
        if ((!employee.emp_home_ok)||(!%IsNumeric(^a(employee.emp_home_ok))))
            clear employee.emp_home_ok
        if ((!employee.emp_address_zip)||(!%IsNumeric(^a(employee.emp_address_zip))))
            clear employee.emp_address_zip

        ;;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1))=%char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1))=%char(0)

        ;;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1))=%char(0)

        ;;Assign data to any temporary time or user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;;Execute the INSERT statement

        if (%ssc_execute(a_dbchn,csr_employee_insert1,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;If it's a "row exists" then return 2
                using dberror select
                (-2627),
                begin
                    ;;Duplicate key
                    errtxt = "Duplicate key detected in database!"
                    sts = 2
                end
                (),
                    nop
                endusing
            end
            else
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                sts = 0
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn sts

endfunction

;;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <param name="a_terminal">Terminal number channel to log errors on.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeInsertRows, ^val

    required in  a_dbchn,     i
    required in  a_commit_mode, i
    required in  a_data,      i
    optional out a_errtxt,    a
    optional out a_exception, i
    optional in  a_terminal,  i
    endparams

    .include "CONNECTDIR:ssql.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        dberror     ,int        ;;Database error number
        rows        ,int        ;;Number of rows to insert
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        ex_ms       ,int        ;;Size of exception array
        ex_mc       ,int        ;;Items in exception array
        continue    ,int        ;;Continue after an error
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Employee ("
        & +              '"EmpId",' ;#1
        & +              '"EmpFirstName",' ;#2
        & +              '"EmpLastName",' ;#3
        & +              '"EmpDept",' ;#4
        & +              '"EmpHireDate",' ;#5
        & +              '"EmpPhoneWork",' ;#6
        & +              '"EmpPhoneHome",' ;#7
        & +              '"EmpPhoneCell",' ;#8
        & +              '"EmpPaid",' ;#9
        & +              '"EmpHomeOk",' ;#10
        & +              '"EmpDateOfBirth",' ;#11
        & +              '"EmpHireTime",' ;#12
        & +              '"EmpEmail",' ;#13
        & +              '"EmpAddressStreet",' ;#14
        & +              '"EmpAddressCity",' ;#15
        & +              '"EmpAddressState",' ;#16
        & +              '"EmpAddressZip"' ;#17
        & +              ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15,:16,:17)"
    endliteral

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    static record
        tmpEmpHireTime, a5      ;;Storage for HH:MM time field
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        csr_employee_insert2, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (csr_employee_insert2 == 0)

    if (^passed(a_exception)&&a_exception)
        clear a_exception

    ;;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data)/^size(inpbuf))

    ;;If enabled, disable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"no")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to disable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;;Start a database transaction

    if (ok)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_employee_insert2,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_employee_insert2,17,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_home,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    employee.emp_home_ok,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;;Load data into bound record

            employee = ^m(inpbuf[cnt],a_data)

            ;;Clean up any alpha variables

            employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
            employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
            employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
            employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
            employee.emp_phone_home = %atrim(employee.emp_phone_home)+%char(0)
            employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
            employee.emp_email = %atrim(employee.emp_email)+%char(0)
            employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
            employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
            employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

            ;;Clean up any decimal variables

            if ((!employee.emp_id)||(!%IsNumeric(^a(employee.emp_id))))
                clear employee.emp_id
            if ((!employee.emp_paid)||(!%IsNumeric(^a(employee.emp_paid))))
                clear employee.emp_paid
            if ((!employee.emp_home_ok)||(!%IsNumeric(^a(employee.emp_home_ok))))
                clear employee.emp_home_ok
            if ((!employee.emp_address_zip)||(!%IsNumeric(^a(employee.emp_address_zip))))
                clear employee.emp_address_zip

            ;;Clean up any date variables

            if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
                ^a(employee.emp_hire_date(1:1))=%char(0)
            if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
                ^a(employee.emp_date_of_birth(1:1))=%char(0)

            ;;Clean up any time variables

            if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
                ^a(employee.emp_hire_time(1:1))=%char(0)

            ;;Assign any time or user-defined timestamp fields

            tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

            ;;Execute the statement

            if (%ssc_execute(a_dbchn,csr_employee_insert2,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to execute SQL statement"

                clear continue

                ;;Are we logging errors?
                if (^passed(a_terminal)&&(a_terminal))
                begin
                    writes(a_terminal,errtxt(1:length))
                    continue=1
                end

                ;;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=employee
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If necessary, re-enable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"yes")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to enable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception)&&a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = %atrim(errtxt)+" [Database error "+%string(dberror)+"]"
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Updates a row in the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeUpdate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_rows,   i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        transaction ,boolean    ;;Transaction in progress
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        rows        ,int        ;;Number of rows updated
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, 'UPDATE Employee SET '
        & +              '"EmpId"=:1,'
        & +              '"EmpFirstName"=:2,'
        & +              '"EmpLastName"=:3,'
        & +              '"EmpDept"=:4,'
        & +              '"EmpHireDate"=:5,'
        & +              '"EmpPhoneWork"=:6,'
        & +              '"EmpPhoneHome"=:7,'
        & +              '"EmpPhoneCell"=:8,'
        & +              '"EmpPaid"=:9,'
        & +              '"EmpHomeOk"=:10,'
        & +              '"EmpDateOfBirth"=:11,'
        & +              '"EmpHireTime"=:12,'
        & +              '"EmpEmail"=:13,'
        & +              '"EmpAddressStreet"=:14,'
        & +              '"EmpAddressCity"=:15,'
        & +              '"EmpAddressState"=:16,'
        & +              '"EmpAddressZip"=:17'
        & +              ' WHERE "EmpId"=:18  '
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;;Storage for HH:MM time field
    endrecord

    global common
        csr_employee_update, i4
    endcommon
proc

    init local_data
    ok = true

    openAndBind = (csr_employee_update == 0)

    if (^passed(a_rows))
        clear a_rows

    ;;Load the data into the bound record

    employee = a_data

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction = true
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open a cursor for the UPDATE statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,csr_employee_update,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be updated

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_employee_update,17,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_home,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    employee.emp_home_ok,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Bind the host variables for the key segments / WHERE clause

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,csr_employee_update,1,employee.emp_id)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind key variables"
        end
    end

    ;;Update the row in the database

    if (ok)
    begin
        ;;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_home = %atrim(employee.emp_phone_home)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsNumeric(^a(employee.emp_id))))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsNumeric(^a(employee.emp_paid))))
            clear employee.emp_paid
        if ((!employee.emp_home_ok)||(!%IsNumeric(^a(employee.emp_home_ok))))
            clear employee.emp_home_ok
        if ((!employee.emp_address_zip)||(!%IsNumeric(^a(employee.emp_address_zip))))
            clear employee.emp_address_zip

        ;;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1)) = %char(0)

        ;;Assign any time and user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        if (%ssc_execute(a_dbchn,csr_employee_update,SSQL_STANDARD,,rows)==SSQL_NORMAL) then
        begin
            if (^passed(a_rows))
                a_rows = rows
        end
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;Return error message

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeDelete, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_key,    a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, stack record="employee"

    external function
        EmployeeKeyToRecord, a
    endexternal

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a512       ;;Error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Put the unique key value into the record

;TODO: NEED TO FIGURE OUT HOW TO DEAL WITH this
;      THE PASSED IN KEY VALUE WILL BE A KEY ON THE MAPPED FILE
    employee = %EmployeeKeyToRecord(a_key)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open a cursor for the DELETE statement

    if (ok)
    begin
        sql = 'DELETE FROM "Employee" WHERE'
        & + ' "EmpId"=' + "'" + %string(employee.emp_id) + "' "
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute the query

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

   ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeClear, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open cursor for the SQL statement

    if (ok)
    begin
        sql = 'TRUNCATE TABLE "Employee"'
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute SQL statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes the Employee table from the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeDrop, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a512       ;;Returned error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Close any open cursors

    xcall EmployeeClose(a_dbchn,a_commit_mode)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
        end
    end

    ;;Open cursor for DROP TABLE statement

    if (ok)
    begin
        if (%ssc_open(a_dbchn,cursor,"DROP TABLE Employee",SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute DROP TABLE statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;Check if the error was that the table did not exist
                if (dberror==-3701) then
                    clear errtxt
                else
                    ok = false
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
                ok = false
            end
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            a_errtxt = ""
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_logex">Log exception records?</param>
;;; <param name="a_terminal">Terminal channel to log errors on.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <param name="a_progress">Report progress.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeLoad, ^val

    required in  a_dbchn,    i
    required in  a_commit_mode, i
    optional out a_errtxt,   a
    optional in  a_logex,    i
    optional in  a_terminal, i
    optional out a_added,    n
    optional out a_failed,   n
    optional in  a_progress, n
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        firstRecord ,boolean    ;;Is this the first record?
        filechn     ,int        ;;Data file channel
        mh          ,D_HANDLE   ;;Memory handle containing data to insert
        ms          ,int        ;;Size of memory buffer in rows
        mc          ,int        ;;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;;Memory buffer for exception records
        ex_mc       ,int        ;;Number of records in returned exception array
        ex_ch       ,int        ;;Exception log file channel
        attempted   ,int        ;;Rows being attempted
        ttl_added   ,int        ;;Total rows added
        ttl_failed  ,int        ;;Total failed inserts
        errnum      ,int        ;;Error number
        errtxt      ,a512       ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;;If we are logging exceptions, delete any existing exceptions file.
    if (^passed(a_logex) && a_logex)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;;Open the data file associated with the structure

    if (!(filechn = %EmployeeOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    if (ok)
    begin
        ;;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errtxt = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            ;;If the buffer is full, write it to the database
            if (mc==ms)
                call insert_data
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file

    if (filechn && %chopen(filechn))
        close filechn

    ;;Close the exceptions log file

    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    ;;Return totals

    if (^passed(a_added))
        a_added = ttl_added
    if (^passed(a_failed))
        a_failed = ttl_failed

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%EmployeeInsertRows(a_dbchn,a_commit_mode,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                data cnt, int
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                ;;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;;No exceptions
            ttl_added += attempted
            if ^passed(a_terminal) && a_terminal && ^passed(a_progress) && a_progress
                writes(a_terminal," - " + %string(ttl_added) + " rows inserted")
        end
    end

    clear mc

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_remotepath">Remote export directory or URL</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeBulkLoad, ^val

    required in  a_dbchn,      i
    required in  a_commit_mode, i
    required in  a_localpath,  string
    required in  a_server,     string
    required in  a_port,       string
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    optional in  a_logchannel, n
    optional out a_records,    n
    optional out a_exceptions, n
    optional out a_errtxt,     a
    endparams

    .include "CONNECTDIR:ssql.def"

     stack record local_data
        ok,                     boolean    ;;Return status
        transaction,            boolean
        cursorOpen,             boolean
        remoteBulkLoad,         boolean
        sql,                    string
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        errorFile,              string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int
        exceptionCount,         int
        errtxt,                 a512       ;;Error message text
        fsc,                    @FileServiceClient
        now,                    a20
    endrecord

    .define writelog(x) writes(a_logchannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

proc

    init local_data
    ok = true

    ;;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    if (remoteBulkLoad = ((a_server!=^null) && (a_server.nes." ")))
    begin
        fsc = new FileServiceClient(a_server,a_port)

        now = %datetime
        writelog("Verifying FileService connection")

        if (!fsc.Ping(errtxt))
        begin
            now = %datetime
            writelog(errtxt = "No response from FileService, bulk upload cancelled")
            ok = false
        end
    end

    if (ok)
    begin
        ;;Determine temporary file names

        .ifdef OS_WINDOWS7
        localCsvFile = a_localpath + "\Employee.csv"
        .endc
        .ifdef OS_UNIX
        localCsvFile = a_localpath + "/Employee.csv"
        .endc
        .ifdef OS_VMS
        localCsvFile = a_localpath + "Employee.csv"
        .endc
        localExceptionsFile  = localCsvFile + "_err"
        localExceptionsLog   = localExceptionsFile + ".Error.Txt"

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Employee.csv"
            remoteExceptionsFile = remoteCsvFile + "_err"
            remoteExceptionsLog  = remoteExceptionsFile + ".Error.Txt"
        end

        ;;Make sure there are no files left over from previous operations

        call DeleteFiles

        ;;And export the data

        now = %datetime
        writelog("Exporting delimited file")

        ok = %EmployeeCsv(localCsvFile,recordCount,errtxt)
    end

    if (ok)
    begin
        ;;If necessary, upload the exported file to the database server

        if (remoteBulkLoad) then
        begin
            now = %datetime
            writelog("Uploading delimited file to database host")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errtxt)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    if (ok)
    begin
        ;;Bulk load the database table

        ;;Start a database transaction

        if (a_commit_mode==3)
        begin
            now = %datetime
            writelog("Starting transaction")

            if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
                transaction = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to start transaction"
            end
        end

        ;;Open a cursor for the statement

        if (ok)
        begin
            now = %datetime
            writelog("Opening cursor")

            errorFile = fileToLoad + "_err"

            sql = "BULK INSERT Employee FROM '" + fileToLoad + "' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n', ERRORFILE='" + errorFile + "')"

            if (%ssc_open(a_dbchn,cursor,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_NORMAL) then
                cursorOpen = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to open cursor"
            end
        end

        ;;Set the SQL statement execution timeout to the bulk load value

        if (ok)
        begin
            now = %datetime
            writelog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
            if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to set database timeout"
            end
        end

        ;;Execute the statement

        if (ok)
        begin
            now = %datetime
            writelog("Executing BULK INSERT")
            if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
                begin
                    now = %datetime
                    writelog("Bulk insert error")
                    using dberror select
                    (-4864),
                    begin
                        ;Bulk load data conversion error
                        now = %datetime
                        writelog("Data conversion errors were reported")
                        clear dberror, errtxt
                        call GetExceptionDetails
                    end
                    (),
                    begin
                        errtxt = %string(dberror) + " " + errtxt
                        ok = false
                    end
                    endusing
                end
                else
                begin
                    errtxt="Failed to execute SQL statement"
                    ok = false
                end
            end

            ;;Delete temporary files
            call DeleteFiles
        end

        ;;Set the database timeout back to the regular value

        now = %datetime
        writelog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
            nop

        ;;Commit or rollback the transaction

        if ((a_commit_mode==3) && transaction)
        begin
            if (ok) then
            begin
                now = %datetime
                writelog("COMMIT")
                if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
                begin
                    if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                        errtxt="Failed to commit transaction"
                    ok = false
                end
            end
            else
            begin
                ;;There was an error, rollback the transaction
                now = %datetime
                writelog("ROLLBACK")
                xcall ssc_rollback(a_dbchn,SSQL_TXOFF)
            end
        end

        ;;Close the cursor

        if (cursorOpen)
        begin
            now = %datetime
            writelog("Closing cursor")
            if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;; Return the record count

    if (^passed(a_records))
        a_records = recordCount

    if (^passed(a_exceptions))
        a_exceptions = exceptionCount

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

      now = %datetime
      writelog("BULK ULOAD COMPLETE")

    freturn ok

GetExceptionDetails,

    ;;If we get here then the bulk load reported one or more "data conversion error" issues
    ;;There should be two files on the server

    now = %datetime
    writelog("Data conversion errors, processing exceptions")


    if (remoteBulkLoad) then
    begin
        data fileExists, boolean
        data tmpmsg, string

        if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;;Download the error file
                data exceptionRecords, [#]string

                now = %datetime
                writelog("Downloading remote exceptions data file")

                if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsFile)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    exceptionCount = exceptionRecords.Length

                    now = %datetime
                    writelog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                end
            end
            else
            begin
                ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions data file not found!")
            end
        end
        else
        begin
            ;;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
        end

        ;;Now check for and retrieve the associated exceptions log

        if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;;Download the error file
                data exceptionRecords, [#]string

                now = %datetime
                writelog("Downloading remote exceptions log file")

                if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsLog)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    now = %datetime
                    writelog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                end
            end
            else
            begin
                ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions file not found!")
            end
        end
        else
        begin
            ;;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
        end
    end
    else
    begin
        ;;Local bulk load

        if (File.Exists(localExceptionsFile)) then
        begin
            data ex_ch, int
            data tmprec, a65535
            open(ex_ch=0,i:s,localExceptionsFile)
            repeat
            begin
                reads(ex_ch,tmprec,eof)
                exceptionCount += 1
            end
eof,        close ex_ch
            now = %datetime
            writelog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
        end
        else
        begin
            ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
            now = %datetime
            writelog("Exceptions data file not found!")
        end
    end

    return

DeleteFiles,

    ;;Delete local files

    now = %datetime
    writelog("Deleting local files")

    xcall delet(localCsvFile)
    xcall delet(localExceptionsFile)
    xcall delet(localExceptionsLog)

    ;;Delete remote files

    if (remoteBulkLoad)
    begin
        now = %datetime
        writelog("Deleting remote files")

        fsc.Delete(remoteCsvFile)
        fsc.Delete(remoteExceptionsFile)
        fsc.Delete(remoteExceptionsLog)
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>

subroutine EmployeeClose

    required in  a_dbchn, i
    required in  a_commit_mode, i
    endparams

    .include "CONNECTDIR:ssql.def"

    external common
        csr_employee_insert1, i4
        csr_employee_insert2, i4
        csr_employee_update,  i4
    endcommon

proc

    if (csr_employee_insert1)
    begin
        if (%ssc_close(a_dbchn,csr_employee_insert1))
            nop
        clear csr_employee_insert1
    end

    if (csr_employee_insert2)
    begin
        if (%ssc_close(a_dbchn,csr_employee_insert2))
            nop
        clear csr_employee_insert2
    end

    if (csr_employee_update)
    begin
        if (%ssc_close(a_dbchn,csr_employee_update))
            nop
        clear csr_employee_update
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Returned error text.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeCsv, ^val
    required in  fileSpec, string
    optional out recordCount, n
    optional out errorMessage, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, record="employee", end

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok,             boolean     ;;Return status
        filechn,        int         ;;Data file channel
        csvchn,         int         ;;CSV file channel
        csvrec,         string      ;;A CSV file record
        errnum,         int         ;;Error number
        records,        int         ;;Number of records exported
        errtxt,         a512        ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Open the data file associated with the structure

    if (!(filechn=%EmployeeOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    if (ok)
    begin
        ;;Create the local CSV file
        .ifdef OS_WINDOWS7
        open(csvchn=0,o:s,fileSpec)
        .endc
        .ifdef OS_UNIX
        open(csvchn=0,o,fileSpec)
        .endc
        .ifdef OS_VMS
        open(csvchn=0,o,fileSpec,OPTIONS:"/stream")
        .endc

        ;;Add a row of column headers
        .ifdef OS_WINDOWS7
        writes(csvchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneHome|EmpPhoneCell|EmpPaid|EmpHomeOk|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip")
        .else
        puts(csvchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneHome|EmpPhoneCell|EmpPaid|EmpHomeOk|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip" + %char(13) + %char(10))
        .endc

        ;;Read and add data file records
        repeat
        begin
            ;;Get the next record from the input file
            try
            begin
                reads(filechn,employee)

                ;;Make sure there are no | characters in the data
                if (%instr(1,employee,"|"))
                begin
                    data tmpData, string, employee
                    tmpData.Replace("|"," ")
                    employee = tmpData
                end

                records += 1
                csvrec = ""
                &    + %string(employee.emp_id) + "|"
                &    + %atrim(employee.emp_first_name) + "|"
                &    + %atrim(employee.emp_last_name) + "|"
                &    + %atrim(employee.emp_dept) + "|"
                &    + %string(employee.emp_hire_date,"XXXX-XX-XX") + "|"
                &    + %atrim(employee.emp_phone_work) + "|"
                &    + %atrim(employee.emp_phone_home) + "|"
                &    + %atrim(employee.emp_phone_cell) + "|"
                &    + %string(employee.emp_paid) + "|"
                &    + %string(employee.emp_home_ok) + "|"
                &    + %string(employee.emp_date_of_birth,"XXXX-XX-XX") + "|"
                &    + %string(employee.emp_hire_time,"XX:XX") + "|"
                &    + %atrim(employee.emp_email) + "|"
                &    + %atrim(employee.emp_address_street) + "|"
                &    + %atrim(employee.emp_address_city) + "|"
                &    + %atrim(employee.emp_address_state) + "|"
                &    + %string(employee.emp_address_zip) + ""

                .ifdef OS_WINDOWS7
                writes(csvchn,csvrec)
                .else
                puts(csvchn,csvrec + %char(13) + %char(10))
                .endc
            end
            catch (e, @EndOfFileException)
            begin
                exitloop
            end
            catch (e, @Exception)
            begin
                ok = false
                errtxt = "Unexpected error when reading data file: " + e.Message
                exitloop
            end
            endtry
        end
    end

    ;;Close the CSV file
    if (csvchn)
        close csvchn

    ;;Close the data file
    if (filechn && %chopen(filechn))
        close filechn

    ;;Return the record count
    if (^passed(recordCount))
        recordCount = records

    ;;Return the error text
    if (^passed(errorMessage))
        errorMessage = errtxt

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Opens the REPLICATOR_DATA:EMPLOYEE.ISM for input.
;;; </summary>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns the channel number, or 0 if an error occured.</returns>

function EmployeeOpenInput, ^val
    optional out errorMessage, a  ;;Returned error text
    endparams
    stack record
        ch, int
        errmsg, a128
    endrecord
proc

    try
    begin
        open(ch=0,i:i,"REPLICATOR_DATA:EMPLOYEE.ISM")
        errmsg = ""
    end
    catch (ex, @Exception)
    begin
        errmsg = ex.Message
        clear ch
    end
    endtry

    if (^passed(errorMessage))
        errorMessage = errmsg

    freturn ch

endfunction

;;*****************************************************************************
;;; <summary>
;;; Loads a unique key value into the respective fields in a record.
;;; </summary>
;;; <param name="aKeyValue">Unique key value.</param>
;;; <returns>Returns a record containig only the unique key segment data.</returns>

function EmployeeKeyToRecord, a

    required in aKeyValue, a
    endparams

    .include "EMPLOYEE" repository, stack record="employee", end

    stack record
        segPos, int
    endrecord

proc

    clear employee
    segPos = 1

    employee.emp_id = ^d(aKeyValue(segPos:6))
    segPos += 6

    freturn employee

endfunction


function EmployeeLength ,^val
proc
    freturn 300
endfunction

function EmployeeType, ^val
    required out fileType, a
proc
    fileType = "DBL ISAM"
    freturn true
endfunction
