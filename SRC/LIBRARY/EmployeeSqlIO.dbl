;*****************************************************************************
;
; File:        EmployeeSqlIO.dbl
;
; Description: Various functions that performs SQL I/O for EMPLOYEE
;
;*****************************************************************************
; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;*****************************************************************************

import ReplicationLibrary
import Synergex.SynergyDE.Select

.ifndef strEmployee
.include "EMPLOYEE" repository, structure="strEmployee", end
.endc

;*****************************************************************************
;;; <summary>
;;; Determines if the Employee table exists in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_temp_table">Use TEMP table?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function EmployeeExists, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_temp_table, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        sql         ,string ;SQL statement
        error       ,int    ;Returned error number
        dberror     ,int    ;Database error number
        cursor      ,int    ;Database cursor
        length      ,int    ;Length of a string
        table_name  ,a128   ;Retrieved table name
        errtxt      ,a512   ;Error message text
    endrecord

proc

    init local_data

    if (a_temp_table) then
        sql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='EmployeeTEMP'"
    else
        sql = "SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Employee'"

    ;Open a cursor for the SELECT statement

    if (%ssc_open(a_dbchn,cursor,sql,SSQL_SELECT)==SSQL_FAILURE)
    begin
        error=-1
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to open cursor"
        else
            xcall ThrowOnCommunicationError("EmployeeExists",dberror,errtxt)
    end

    ;Bind host variables to receive the data

    if (!error)
    begin
        if (%ssc_define(a_dbchn,cursor,1,table_name)==SSQL_FAILURE)
        begin
            error=-1
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to bind variable"
            else
                xcall ThrowOnCommunicationError("EmployeeExists",dberror,errtxt)
        end
    end

    ;Move data to host variables

    if (!error)
    begin
        if (%ssc_move(a_dbchn,cursor,1)==SSQL_NORMAL) then
        begin
            error = 1 ;Table exists
        end
        else
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to execute SQL Statement"
            else
                xcall ThrowOnCommunicationError("EmployeeExists",dberror,errtxt)
        end
    end

    ;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (!error)
            begin
                error=-1
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeExists",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (error) then
            a_errtxt = errtxt
        else
            clear a_errtxt
    end

    freturn error

endfunction

;*****************************************************************************
;;; <summary>
;;; Creates the Employee table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data_compression">Data compression mode</param>
;;; <param name="a_temp_table">Use TEMP table?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeCreate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data_compression, i
    required in  a_temp_table, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;Return status
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        transaction ,int        ;Transaction in process
        errtxt      ,a512       ;Returned error message text
        tableName   ,string     ;Table name
        sql         ,string     ;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
        end
    end

    ;Create the database table and primary key constraint

    if (ok)
    begin
        if (a_temp_table) then
            tableName = "EmployeeTEMP"
        else
            tableName = "Employee"

        sql = 'CREATE TABLE ' + tableName + ' ('
        & + '"EmpId" DECIMAL(8) NOT NULL,'
        & + '"EmpFirstName" VARCHAR(20) NOT NULL,'
        & + '"EmpLastName" VARCHAR(20) NOT NULL,'
        & + '"EmpDept" VARCHAR(15) NOT NULL,'
        & + '"EmpHireDate" DATE,'
        & + '"EmpPhoneWork" VARCHAR(14),'
        & + '"EmpPhoneCell" VARCHAR(14),'
        & + '"EmpPaid" DECIMAL(1),'
        & + '"EmpDateOfBirth" DATE,'
        & + '"EmpHireTime" TIME(0),'
        & + '"EmpEmail" VARCHAR(40),'
        & + '"EmpAddressStreet" VARCHAR(30),'
        & + '"EmpAddressCity" VARCHAR(20),'
        & + '"EmpAddressState" VARCHAR(2),'
        & + '"EmpAddressZip" DECIMAL(5),'
        & + 'CONSTRAINT PK_' + tableName + ' PRIMARY KEY CLUSTERED("EmpId" ASC)'
        & + ')'

        using a_data_compression select
        (2),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        (3),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        endusing

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Grant access permissions

    if (ok)
    begin
        sql = 'GRANT ALL ON ' + tableName + ' TO PUBLIC'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to open cursor"
        else
            xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to execute SQL statement"
        else
            xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeCreate",dberror,errtxt)
            end
        end
        clear cursor
    end

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Employee table if they do not exist.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_data_compression">Data compression mode.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    required in  a_data_compression, n
    optional in  a_logchannel, n
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok                  ,boolean    ;Return status
        dberror             ,int        ;Database error number
        cursor              ,int        ;Database cursor
        length              ,int        ;Length of a string
        transaction         ,int        ;Transaction in process
        keycount            ,int        ;Total number of keys
        errtxt              ,a512       ;Returned error message text
        now                 ,a20        ;Current date and time
        sql                 ,string     ;SQL statement
    endrecord

proc
    init local_data
    ok = true

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
        end
    end

    ;Set the SQL statement execution timeout to the bulk load value

    if (ok)
    begin
        now = %datetime
        Logger.VerboseLog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to set database timeout"
            else
                xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
        end
    end

    ;Create index 1 (Department ID)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_EmpDept",errtxt))
    begin
        sql = 'CREATE  INDEX IX_Employee_EmpDept ON "Employee"("EmpDept" ASC)'

        using a_data_compression select
        (2),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        (3),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        endusing

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end

        now = %datetime

        if (ok) then
        begin
            Logger.VerboseLog("Added index IX_Employee_EmpDept")
        end
        else
        begin
            Logger.ErrorLog("Failed to add index IX_Employee_EmpDepts")
            ok = true
        end
    end

    ;Create index 2 (Last name)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_EmpLastName",errtxt))
    begin
        sql = 'CREATE  INDEX IX_Employee_EmpLastName ON "Employee"("EmpLastName" ASC)'

        using a_data_compression select
        (2),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        (3),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        endusing

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end

        now = %datetime

        if (ok) then
        begin
            Logger.VerboseLog("Added index IX_Employee_EmpLastName")
        end
        else
        begin
            Logger.ErrorLog("Failed to add index IX_Employee_EmpLastNames")
            ok = true
        end
    end

    ;Create index 3 (State)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_StateCode",errtxt))
    begin
        sql = 'CREATE  INDEX IX_Employee_StateCode ON "Employee"("EmpAddressState" ASC)'

        using a_data_compression select
        (2),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        (3),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        endusing

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end

        now = %datetime

        if (ok) then
        begin
            Logger.VerboseLog("Added index IX_Employee_StateCode")
        end
        else
        begin
            Logger.ErrorLog("Failed to add index IX_Employee_StateCodes")
            ok = true
        end
    end

    ;Create index 4 (Zip code)

    if (ok && !%IndexExists(a_dbchn,"IX_Employee_ZipCode",errtxt))
    begin
        sql = 'CREATE  INDEX IX_Employee_ZipCode ON "Employee"("EmpAddressZip" ASC)'

        using a_data_compression select
        (2),
            sql = sql + " WITH(DATA_COMPRESSION=ROW)"
        (3),
            sql = sql + " WITH(DATA_COMPRESSION=PAGE)"
        endusing

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end

        now = %datetime

        if (ok) then
        begin
            Logger.VerboseLog("Added index IX_Employee_ZipCode")
        end
        else
        begin
            Logger.ErrorLog("Failed to add index IX_Employee_ZipCodes")
            ok = true
        end
    end


    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
            end
        end
    end

    ;Set the database timeout back to the regular value

    now = %datetime
    Logger.VerboseLog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
    if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
        nop

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to open cursor"
        else
            xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to execute SQL statement"
        else
            xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeIndex",dberror,errtxt)
            end
        end
        clear cursor
    end

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Employee table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeUnIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;Return status
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        transaction ,int        ;Transaction in process
        keycount    ,int        ;Total number of keys
        errtxt      ,a512       ;Returned error message text
        sql         ,string     ;SQL statement
    endrecord

proc
    init local_data
    ok = true

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
        end
    end

    ;Drop index 1 (Department ID)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_EmpDept ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Drop index 2 (Last name)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_EmpLastName ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Drop index 3 (State)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_StateCode ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Drop index 4 (Zip code)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Employee_ZipCode ON "Employee"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to open cursor"
        else
            xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
            errtxt="Failed to execute SQL statement"
        else
            xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeUnIndex",dberror,errtxt)
            end
        end
        clear cursor
    end

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Insert a row into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function EmployeeInsert, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;OK to continue
        openAndBind ,boolean    ;Should we open the cursor and bind data this time?
        sts         ,int        ;Return status
        dberror     ,int        ;Database error number
        transaction ,int        ;Transaction in progress
        length      ,int        ;Length of a string
        errtxt      ,a512       ;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Employee ("
        & +              '"EmpId",'
        & +              '"EmpFirstName",'
        & +              '"EmpLastName",'
        & +              '"EmpDept",'
        & +              '"EmpHireDate",'
        & +              '"EmpPhoneWork",'
        & +              '"EmpPhoneCell",'
        & +              '"EmpPaid",'
        & +              '"EmpDateOfBirth",'
        & +              '"EmpHireTime",'
        & +              '"EmpEmail",'
        & +              '"EmpAddressStreet",'
        & +              '"EmpAddressCity",'
        & +              '"EmpAddressState",'
        & +              '"EmpAddressZip"'
        & +              ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15)"
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

    global common
        c1Employee, i4, 0
    endcommon


proc

    init local_data
    ok = true
    sts = 1
    openAndBind = (c1Employee == 0)

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
        end
    end

    ;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c1Employee,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
        end
    end

    ;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c1Employee,15,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to bind variables"
            else
                xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
        end
    end

    ;Insert the row into the database

    if (ok)
    begin
        ;Load the data into the bound record

        employee = a_data

        ;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
            clear employee.emp_paid
        if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
            clear employee.emp_address_zip

        ;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1))=%char(0)

        ;Assign data to any temporary time or user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types


        ;Execute the INSERT statement

        if (%ssc_execute(a_dbchn,c1Employee,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;If it's a "row exists" then return 2
                using dberror select
                (-2627),
                begin
                    ;Duplicate key
                    errtxt = "Duplicate key detected in database!"
                    sts = 2
                end
                (),
                begin
                    xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
                end
                endusing
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
            end
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                sts = 0
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeInsert",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn sts

endfunction

;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <param name="a_terminal">Terminal number channel to log errors on.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeInsertRows, ^val

    required in  a_dbchn,     i
    required in  a_commit_mode, i
    required in  a_data,      i
    optional out a_errtxt,    a
    optional out a_exception, i
    optional in  a_terminal,  i
    endparams

    .include "CONNECTDIR:ssql.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;Return status
        openAndBind ,boolean    ;Should we open the cursor and bind data this time?
        dberror     ,int        ;Database error number
        rows        ,int        ;Number of rows to insert
        transaction ,int        ;Transaction in progress
        length      ,int        ;Length of a string
        ex_ms       ,int        ;Size of exception array
        ex_mc       ,int        ;Items in exception array
        continue    ,int        ;Continue after an error
        errtxt      ,a512       ;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Employee ("
        & +              '"EmpId",' ;#1
        & +              '"EmpFirstName",' ;#2
        & +              '"EmpLastName",' ;#3
        & +              '"EmpDept",' ;#4
        & +              '"EmpHireDate",' ;#5
        & +              '"EmpPhoneWork",' ;#6
        & +              '"EmpPhoneCell",' ;#7
        & +              '"EmpPaid",' ;#8
        & +              '"EmpDateOfBirth",' ;#9
        & +              '"EmpHireTime",' ;#10
        & +              '"EmpEmail",' ;#11
        & +              '"EmpAddressStreet",' ;#12
        & +              '"EmpAddressCity",' ;#13
        & +              '"EmpAddressState",' ;#14
        & +              '"EmpAddressZip"' ;#15
        & +              ") VALUES(:1,:2,:3,:4,:5,:6,:7,:8,:9,:10,:11,:12,:13,:14,:15)"
    endliteral

    .include "EMPLOYEE" repository, structure="inpbuf", nofields, end
    .include "EMPLOYEE" repository, static record="employee", end

    static record
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
        ,a1                         ;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        c2Employee, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (c2Employee == 0)

    if (^passed(a_exception)&&a_exception)
        clear a_exception

    ;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data)/^size(inpbuf))

    ;If enabled, disable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"no")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to disable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;Start a database transaction

    if (ok)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)
        end
    end

    ;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c2Employee,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)
        end
    end

    ;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c2Employee,15,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to bind variables"
            else
                xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)
        end
    end

    ;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;Load data into bound record

            employee = ^m(inpbuf[cnt],a_data)

            ;Clean up any alpha variables

            employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
            employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
            employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
            employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
            employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
            employee.emp_email = %atrim(employee.emp_email)+%char(0)
            employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
            employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
            employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

            ;Clean up any decimal variables

            if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
                clear employee.emp_id
            if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
                clear employee.emp_paid
            if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
                clear employee.emp_address_zip

            ;Clean up any date variables

            if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
                ^a(employee.emp_hire_date(1:1))=%char(0)
            if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
                ^a(employee.emp_date_of_birth(1:1))=%char(0)

            ;Clean up any time variables

            if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
                ^a(employee.emp_hire_time(1:1))=%char(0)

            ;Assign any time or user-defined timestamp fields

            tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types


            ;Execute the statement

            if (%ssc_execute(a_dbchn,c2Employee,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to execute SQL statement"
                else
                    xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)

                clear continue

                ;Are we logging errors?
                if (^passed(a_terminal)&&(a_terminal))
                begin
                    writes(a_terminal,errtxt(1:length))
                    continue=1
                end

                ;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=employee
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
        end
    end

    ;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeInsertRows",dberror,errtxt)
            end
        end
    end

    ;If necessary, re-enable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"yes")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to enable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception)&&a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = %atrim(errtxt)+" [Database error "+%string(dberror)+"]"
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Updates a row in the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeUpdate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_rows,   i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;OK to continue
        openAndBind ,boolean    ;Should we open the cursor and bind data this time?
        transaction ,boolean    ;Transaction in progress
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        rows        ,int        ;Number of rows updated
        errtxt      ,a512       ;Error message text
    endrecord

    literal
        sql         ,a*, 'UPDATE Employee SET '
        & +              '"EmpId"=:1,'
        & +              '"EmpFirstName"=:2,'
        & +              '"EmpLastName"=:3,'
        & +              '"EmpDept"=:4,'
        & +              '"EmpHireDate"=:5,'
        & +              '"EmpPhoneWork"=:6,'
        & +              '"EmpPhoneCell"=:7,'
        & +              '"EmpPaid"=:8,'
        & +              '"EmpDateOfBirth"=:9,'
        & +              '"EmpHireTime"=:10,'
        & +              '"EmpEmail"=:11,'
        & +              '"EmpAddressStreet"=:12,'
        & +              '"EmpAddressCity"=:13,'
        & +              '"EmpAddressState"=:14,'
        & +              '"EmpAddressZip"=:15'
        & +              ' WHERE "EmpId"=:16  '
    endliteral

    static record
        employee, strEmployee
        tmpEmpHireTime, a5      ;Storage for HH:MM time field
    endrecord

    global common
        c3Employee, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (c3Employee == 0)

    if (^passed(a_rows))
        clear a_rows

    ;Load the data into the bound record

    employee = a_data

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction = true
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
        end
    end

    ;Open a cursor for the UPDATE statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c3Employee,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
        end
    end

    ;Bind the host variables for data to be updated

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c3Employee,15,
        &    employee.emp_id,
        &    employee.emp_first_name,
        &    employee.emp_last_name,
        &    employee.emp_dept,
        &    ^a(employee.emp_hire_date),
        &    employee.emp_phone_work,
        &    employee.emp_phone_cell,
        &    employee.emp_paid,
        &    ^a(employee.emp_date_of_birth),
        &    tmpEmpHireTime,
        &    employee.emp_email,
        &    employee.emp_address_street,
        &    employee.emp_address_city,
        &    employee.emp_address_state,
        &    employee.emp_address_zip)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to bind variables"
            else
                xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
        end
    end

    ;Bind the host variables for the key segments / WHERE clause

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c3Employee,1,employee.emp_id)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to bind key variables"
            else
                xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
        end
    end

    ;Update the row in the database

    if (ok)
    begin
        ;Clean up any alpha fields

        employee.emp_first_name = %atrim(employee.emp_first_name)+%char(0)
        employee.emp_last_name = %atrim(employee.emp_last_name)+%char(0)
        employee.emp_dept = %atrim(employee.emp_dept)+%char(0)
        employee.emp_phone_work = %atrim(employee.emp_phone_work)+%char(0)
        employee.emp_phone_cell = %atrim(employee.emp_phone_cell)+%char(0)
        employee.emp_email = %atrim(employee.emp_email)+%char(0)
        employee.emp_address_street = %atrim(employee.emp_address_street)+%char(0)
        employee.emp_address_city = %atrim(employee.emp_address_city)+%char(0)
        employee.emp_address_state = %atrim(employee.emp_address_state)+%char(0)

        ;Clean up any decimal fields

        if ((!employee.emp_id)||(!%IsDecimalNoNegatives(employee.emp_id)))
            clear employee.emp_id
        if ((!employee.emp_paid)||(!%IsDecimalNoNegatives(employee.emp_paid)))
            clear employee.emp_paid
        if ((!employee.emp_address_zip)||(!%IsDecimalNoNegatives(employee.emp_address_zip)))
            clear employee.emp_address_zip

        ;Clean up any date fields

        if ((!employee.emp_hire_date)||(!%IsDate(^a(employee.emp_hire_date))))
            ^a(employee.emp_hire_date(1:1)) = %char(0)
        if ((!employee.emp_date_of_birth)||(!%IsDate(^a(employee.emp_date_of_birth))))
            ^a(employee.emp_date_of_birth(1:1)) = %char(0)

        ;Clean up any time fields

        if ((!employee.emp_hire_time)||(!%IsTime(^a(employee.emp_hire_time))))
            ^a(employee.emp_hire_time(1:1)) = %char(0)

        ;Assign any time and user-defined timestamp fields

        tmpEmpHireTime = %string(employee.emp_hire_time,"XX:XX")

        ;Assign values to temp fields for any fields with custom data types


        if (%ssc_execute(a_dbchn,c3Employee,SSQL_STANDARD,,rows)==SSQL_NORMAL) then
        begin
            if (^passed(a_rows))
                a_rows = rows
        end
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to execute SQL statement"
            else
                xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeUpdate",dberror,errtxt)
            end
        end
    end

    ;Return error message

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeDelete, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_key,    a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, stack record="employee"

    external function
        EmployeeKeyToRecord, a
    endexternal

    stack record local_data
        ok          ,boolean    ;Return status
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        transaction ,int        ;Transaction in progress
        errtxt      ,a512       ;Error message text
        sql         ,string     ;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;Put the unique key value into the record

    employee = %EmployeeKeyToRecord(a_key)

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
        end
    end

    ;Open a cursor for the DELETE statement

    if (ok)
    begin
        sql = 'DELETE FROM "Employee" WHERE'
        & + ' "EmpId"=' + "'" + %string(employee.emp_id) + "' "
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
        end
    end

    ;Execute the query

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to execute SQL statement"
            else
                xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
        end
    end

    ;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
            end
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeDelete",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_temp_table">Use TEMP table?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeClear, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_temp_table, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;Return status
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        transaction ,int        ;Transaction in process
        errtxt      ,a512       ;Returned error message text
        sql         ,string     ;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
        end
    end

    ;Open cursor for the SQL statement

    if (ok)
    begin
        if (a_temp_table) then
            sql = 'TRUNCATE TABLE EmployeeTEMP'
        else
            sql = 'TRUNCATE TABLE Employee'

        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
        end
    end

    ;Execute SQL statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to execute SQL statement"
            else
                xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
        end
    end

    ;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
            end
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeClear",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Deletes the Employee table from the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_temp_table">Use TEMP table?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeDrop, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_temp_table, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;Return status
        sql         ,string     ;SQL statement
        dberror     ,int        ;Database error number
        cursor      ,int        ;Database cursor
        length      ,int        ;Length of a string
        transaction ,int        ;Transaction in progress
        errtxt      ,a512       ;Returned error message text
    endrecord

proc

    init local_data
    ok = true

    ;Close any open cursors

    xcall EmployeeClose(a_dbchn)

    ;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to start transaction"
            else
                xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
        end
    end

    ;Open cursor for DROP TABLE statement

    if (ok)
    begin
        sql = "DROP TABLE Employee"

        if (a_temp_table)
            sql = sql + "TEMP"

        if (%ssc_open(a_dbchn,cursor,sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                errtxt="Failed to open cursor"
            else
                xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
        end
    end

    ;Execute DROP TABLE statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;Check if the error was that the table did not exist
                if (dberror==-3701) then
                    clear errtxt
                else
                begin
                    ok = false
                    xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
                end
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
                ok = false
            end
        end
    end

    ;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
            end
        end
    end

    ;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to commit transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
            end
        end
        else
        begin
            ;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to rollback transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeDrop",dberror,errtxt)
            end
        end
    end

    ;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_logex">Log exception records?</param>
;;; <param name="a_terminal">Terminal channel to log errors on.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <param name="a_progress">Report progress.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeLoad, ^val

    required in    a_dbchn,         i
    required in    a_commit_mode,   i
    optional out   a_errtxt,        a
    optional in    a_logex,	        i
    optional in    a_terminal,      i
    optional inout a_added,         n
    optional out   a_failed,        n
    optional in    a_progress,      n
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "EMPLOYEE" repository, structure="inpbuf", end
    .include "EMPLOYEE" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;Return status
        firstRecord ,boolean    ;Is this the first record?
        filechn     ,int        ;Data file channel
        mh          ,D_HANDLE   ;Memory handle containing data to insert
        ms          ,int        ;Size of memory buffer in rows
        mc          ,int        ;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;Memory buffer for exception records
        ex_mc       ,int        ;Number of records in returned exception array
        ex_ch       ,int        ;Exception log file channel
        attempted   ,int        ;Rows being attempted
        done_records,int        ;Records loaded
        max_records ,int        ;Maximum records to load
        ttl_added   ,int        ;Total rows added
        ttl_failed  ,int        ;Total failed inserts
        errnum      ,int        ;Error number
        errtxt      ,a512       ;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;If we are logging exceptions, delete any existing exceptions file.
    if (^passed(a_logex) && a_logex)
    begin
        xcall delet("REPLICATOR_LOGDIR:employee_data_exceptions.log")
    end

    ;Open the data file associated with the structure

    if (!(filechn = %EmployeeOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    ;Were we passed a max # records to load

    max_records = (^passed(a_added) && a_added > 0) ? a_added : 0
    done_records = 0

    if (ok)
    begin
        ;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errtxt = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;Close the file

    if (filechn && %chopen(filechn))
        close filechn

    ;Close the exceptions log file

    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    ;Return totals

    if (^passed(a_added))
        a_added = ttl_added
    if (^passed(a_failed))
        a_failed = ttl_failed

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%EmployeeInsertRows(a_dbchn,a_commit_mode,mh,errtxt,ex_mh,a_terminal))
    begin
        ;Any exceptions?
        if (ex_mh) then
        begin
            ;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                data cnt, int
                ;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:employee_data_exceptions.log")
                ;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to REPLICATOR_LOGDIR:employee_data_exceptions.log")
            end
            else
            begin
                ;No, report and error
                ok = false
            end
            ;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;No exceptions
            ttl_added += attempted
            if ^passed(a_terminal) && a_terminal && ^passed(a_progress) && a_progress
                writes(a_terminal,%string(ttl_added) + " rows inserted")
        end
    end

    clear mc

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:EMPLOYEE.ISM into the Employee table via a CSV file.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_server">Server name or IP</param>
;;; <param name="a_port">Server IP port</param>
;;; <param name="a_temp_table">Use temp table</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_bl_batchsz">Bulk load batch size in rows.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeBulkLoad, ^val

    required in  a_dbchn,      i
    required in  a_commit_mode,i
    required in  a_localpath,  a
    required in  a_server,     a
    required in  a_port,       i
    required in  a_temp_table, n
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    required in  a_bl_batchsz, n
    optional in  a_logchannel, n
    optional in  a_ttchannel,  n
    optional out a_records,    n
    optional out a_exceptions, n
    optional out a_errtxt,     a
    endparams

    .include "CONNECTDIR:ssql.def"

     stack record local_data
        ok,                     boolean    ;Return status
        transaction,            boolean
        cursorOpen,             boolean
        remoteBulkLoad,         boolean
        sql,                    string
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        errorFile,              string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int	        ;# records to load / loaded
        exceptionCount,         int
        errtxt,                 a512        ;Error message text
        fsc,                    @FileServiceClient
        now,                    a20
    endrecord

proc

    init local_data
    ok = true

    ;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    if (remoteBulkLoad = (a_server.nes." "))
    begin
        fsc = new FileServiceClient(a_server,a_port)

        Logger.VerboseLog("Verifying FileService connection")

        if (!fsc.Ping(errtxt))
        begin
            Logger.ErrorLog(errtxt = "No response from FileService, bulk upload cancelled")
            ok = false
        end
    end

    if (ok)
    begin
        ;Determine temporary file names

        .ifdef OS_WINDOWS7
        localCsvFile = a_localpath + "\Employee.csv"
        .endc
        .ifdef OS_UNIX
        localCsvFile = a_localpath + "/Employee.csv"
        .endc
        .ifdef OS_VMS
        localCsvFile = a_localpath + "Employee.csv"
        .endc
        localExceptionsFile  = localCsvFile + "_err"
        localExceptionsLog   = localExceptionsFile + ".Error.Txt"

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Employee.csv"
            remoteExceptionsFile = remoteCsvFile + "_err"
            remoteExceptionsLog  = remoteExceptionsFile + ".Error.Txt"
        end

        ;Make sure there are no files left over from previous operations

        ;Delete local files

        Logger.VerboseLog("Deleting local files")

        xcall delet(localCsvFile)
        xcall delet(localExceptionsFile)
        xcall delet(localExceptionsLog)

        ;Delete remote files

        if (remoteBulkLoad)
        begin
            Logger.VerboseLog("Deleting remote files")

            fsc.Delete(remoteCsvFile)
            fsc.Delete(remoteExceptionsFile)
            fsc.Delete(remoteExceptionsLog)
        end

        ;Were we asked to load a specific number of records?

        recordCount =  (^passed(a_records) && a_records > 0) ? a_records : 0

        ;And export the data

        Logger.Log("Exporting Employee to delimited file")

        ok = %EmployeeCsv(localCsvFile,recordCount,errtxt)

    end

    if (ok)
    begin
        ;If necessary, upload the exported file to the database server

        if (remoteBulkLoad) then
        begin
            Logger.VerboseLog("Uploading delimited file to database host")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errtxt)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    if (ok)
    begin
        ;Bulk load the database table

        ;Start a database transaction

        if (a_commit_mode==3)
        begin
            Logger.VerboseLog("Starting transaction")

            if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
                transaction = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to start transaction"
                else
                    xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
            end
        end

        ;Open a cursor for the statement

        if (ok)
        begin
            Logger.VerboseLog("Opening cursor")

            errorFile = fileToLoad + "_err"

            sql = "BULK INSERT Employee"

            if (a_temp_table)
                sql = sql + "TEMP"

            sql = sql + " FROM '" + fileToLoad + "' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n',MAXERRORS=100000000,ERRORFILE='" + errorFile + "'"

            if (a_bl_batchsz > 0)
            begin
                sql = sql + ",BATCHSIZE=" + %string(a_bl_batchsz)
            end

           sql = sql + ")"

            if (%ssc_open(a_dbchn,cursor,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_NORMAL) then
                cursorOpen = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to open cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
            end
        end

        ;Set the SQL statement execution timeout to the bulk load value

        if (ok)
        begin
            Logger.VerboseLog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")

            if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to set database timeout"
                else
                    xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
            end
        end

        ;Execute the statement

        if (ok)
        begin
            Logger.VerboseLog("Executing BULK INSERT")
            if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
                begin
                    xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)

                    Logger.ErrorLog("Bulk insert error")

                    using dberror select
                    (-4864),
                    begin
                        ;Bulk load data conversion error
                        Logger.ErrorLog("Data conversion errors were reported")
                        clear dberror, errtxt
                        call GetExceptionDetails
                    end
                    (),
                    begin
                        errtxt = %string(dberror) + " " + errtxt
                        ok = false
                    end
                    endusing
                end
                else
                begin
                    errtxt="Failed to execute SQL statement"
                    ok = false
                end
            end

;            ;Delete temporary files
;
;            ;Delete local files
;
;            Logger.VerboseLog(Deleting local files")
;
;            xcall delet(localCsvFile)
;            xcall delet(localExceptionsFile)
;            xcall delet(localExceptionsLog)
;
;            ;Delete remote files
;
;            if (remoteBulkLoad)
;            begin
;                Logger.VerboseLog("Deleting remote files")
;                fsc.Delete(remoteCsvFile)
;                fsc.Delete(remoteExceptionsFile)
;                fsc.Delete(remoteExceptionsLog)
;            end
        end

        ;Commit or rollback the transaction

        if ((a_commit_mode==3) && transaction)
        begin
            if (ok) then
            begin
                Logger.VerboseLog("Commiting transaction")
                if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
                begin
                    ok = false
                    if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                        errtxt="Failed to commit transaction"
                    else
                        xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
                end
            end
            else
            begin
                ;There was an error, rollback the transaction
                Logger.VerboseLog("Rolling back transaction")
                if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
                begin
                    ok = false
                    if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                        errtxt="Failed to rollback transaction"
                    else
                        xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
                end
            end
        end

        ;Set the database timeout back to the regular value

        Logger.VerboseLog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
            nop

        ;Close the cursor

        if (cursorOpen)
        begin
            Logger.VerboseLog("Closing cursor")
            if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE) then
                    errtxt="Failed to close cursor"
                else
                    xcall ThrowOnCommunicationError("EmployeeBulkLoad",dberror,errtxt)
            end
        end
    end

    ;Return the record and cleared field counts

    if (^passed(a_records))
        a_records = recordCount

    if (^passed(a_exceptions))
        a_exceptions = exceptionCount

    ;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    freturn ok

GetExceptionDetails,

    ;If we get here then the bulk load reported one or more "data conversion error" issues
    ;There should be two files on the server

    Logger.ErrorLog("Data conversion errors, processing exceptions")

    if (remoteBulkLoad) then
    begin
        data fileExists, boolean
        data tmpmsg, string

        if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;Download the error file
                data exceptionRecords, [#]string
                data errorMessage, string

                Logger.Log("Downloading remote exceptions data file")

                if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords,errorMessage))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsFile)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    exceptionCount = exceptionRecords.Length

                    Logger.Log(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                end
            end
            else
            begin
                ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                Logger.ErrorLog("Remote exceptions data file not found!")
            end
        end
        else
        begin
            ;Failed to determine if file exists
            Logger.ErrorLog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
        end

        ;Now check for and retrieve the associated exceptions log

        if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;Download the error file
                data exceptionRecords, [#]string
                data errorMessage, string

                Logger.VerboseLog("Downloading remote exceptions log file")

                if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords,errorMessage))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsLog)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    Logger.VerboseLog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                end
            end
            else
            begin
                ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                Logger.ErrorLog("Remote exceptions file not found!")
            end
        end
        else
        begin
            ;Failed to determine if file exists
            Logger.ErrorLog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
        end
    end
    else
    begin
        ;Local bulk load

        if (File.Exists(localExceptionsFile)) then
        begin
            data ex_ch, int
            data tmprec, a65535
            open(ex_ch=0,i:s,localExceptionsFile)
            repeat
            begin
                reads(ex_ch,tmprec,eof)
                exceptionCount += 1
            end
eof,        close ex_ch
            Logger.Log(%string(exceptionCount) + " exception items are in " + localExceptionsFile)
        end
        else
        begin
            ;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
            Logger.ErrorLog("Exceptions data file not found!")
        end
    end

    return

endfunction

;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Employee table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>

subroutine EmployeeClose
    required in  a_dbchn, i
    endparams

    .include "CONNECTDIR:ssql.def"

    external common
        c1Employee, i4
        c2Employee, i4
        c3Employee,  i4
    endcommon

proc

    if (c1Employee)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c1Employee))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c1Employee
        end
        endtry
    end

    if (c2Employee)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c2Employee))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c2Employee
        end
        endtry
    end

    if (c3Employee)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c3Employee))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c3Employee
        end
        endtry
    end

    xreturn

endsubroutine

;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:EMPLOYEE.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Passed number of records to export, returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function EmployeeCsv, boolean
    required in    fileSpec, a
    optional inout recordCount, n
    optional out   errorMessage, a

    .include "EMPLOYEE" repository, record="employee", end

    .define EXCEPTION_BUFSZ 100

    external function
        IsDecimalNo,                    boolean
        MakeDateForCsv,                 a
        MakeDecimalForCsvNegatives,     a
        MakeDecimalForCsvNoNegatives,   a
        MakeTimeForCsv,                 a
    endexternal

.align
    stack record local_data
        ok,                             boolean     ;Return status
        filechn,                        int         ;Data file channel
        outchn,                         int         ;CSV file channel
        outrec,                         string      ;A CSV file record
        records,                        int         ;Number of records exported
        pos,                            int         ;Position in a string
        recordsMax,                     int         ;Max # or records to export
        errtxt,                         a512        ;Error message text
    endrecord

proc

    ok = true
    clear records, errtxt

    ;Were we given a max # or records to export?

    recordsMax = (^passed(recordCount) && recordCount > 0) ? recordCount : 0

    ;Open the data file associated with the structure

    if (!(filechn=%EmployeeOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    ;Create the local CSV file

    if (ok)
    begin
        .ifdef OS_WINDOWS7
        open(outchn=0,o:s,fileSpec)
        .endc
        .ifdef OS_UNIX
        open(outchn=0,o,fileSpec)
        .endc
        .ifdef OS_VMS
        open(outchn=0,o,fileSpec,OPTIONS:"/stream")
        .endc

        ;Add a row of column headers
        .ifdef OS_WINDOWS7
        writes(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip")
        .else
        puts(outchn,"EmpId|EmpFirstName|EmpLastName|EmpDept|EmpHireDate|EmpPhoneWork|EmpPhoneCell|EmpPaid|EmpDateOfBirth|EmpHireTime|EmpEmail|EmpAddressStreet|EmpAddressCity|EmpAddressState|EmpAddressZip" + %char(13) + %char(10))
        .endc

        ;Read and add data file records
        foreach employee in new Select(new From(filechn,Q_NO_GRFA,0,employee))
        begin
            ;Make sure there are no | characters in the data
            while (pos = %instr(1,employee,"|"))
            begin
                clear employee(pos:1)
            end

            incr records

            if (recordsmax && (records > recordsMax))
            begin
                decr records
                exitloop
            end

            outrec = ""
            &    + (employee.emp_id ? %MakeDecimalForCsvNoNegatives(employee.emp_id) + "|" : "0|")
            &    + (employee.emp_first_name ? %atrim(employee.emp_first_name) + "|" : "|")
            &    + (employee.emp_last_name ? %atrim(employee.emp_last_name) + "|" : "|")
            &    + (employee.emp_dept ? %atrim(employee.emp_dept) + "|" : "|")
            &    + (employee.emp_hire_date ? %string(employee.emp_hire_date,"XXXX-XX-XX") + "|" : "|")
            &    + (employee.emp_phone_work ? %atrim(employee.emp_phone_work) + "|" : "|")
            &    + (employee.emp_phone_cell ? %atrim(employee.emp_phone_cell) + "|" : "|")
            &    + (employee.emp_paid ? %MakeDecimalForCsvNoNegatives(employee.emp_paid) + "|" : "0|")
            &    + (employee.emp_date_of_birth ? %string(employee.emp_date_of_birth,"XXXX-XX-XX") + "|" : "|")
            &    + (employee.emp_hire_time ? %MakeTimeForCsv(employee.emp_hire_time) + "|" : "|")
            &    + (employee.emp_email ? %atrim(employee.emp_email) + "|" : "|")
            &    + (employee.emp_address_street ? %atrim(employee.emp_address_street) + "|" : "|")
            &    + (employee.emp_address_city ? %atrim(employee.emp_address_city) + "|" : "|")
            &    + (employee.emp_address_state ? %atrim(employee.emp_address_state) + "|" : "|")
            &    + (employee.emp_address_zip ? %MakeDecimalForCsvNoNegatives(employee.emp_address_zip) : "")

            .ifdef OS_WINDOWS7
            writes(outchn,outrec)
            .else
            puts(outchn,outrec + %char(13) + %char(10))
            .endc
        end
    end

eof,

    ;Close the file
    if (filechn && %chopen(filechn))
    begin
        close filechn
    end

    ;Close the CSV file
    if (outchn && %chopen(outchn))
    begin
        close outchn
    end

    ;Return the record count
    if (^passed(recordCount))
        recordCount = records

    ;Return the error text
    if (^passed(errorMessage))
        errorMessage = errtxt

    freturn ok

endfunction

;*****************************************************************************
;;; <summary>
;;; Opens the REPLICATOR_DATA:EMPLOYEE.ISM for input.
;;; </summary>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns the channel number, or 0 if an error occured.</returns>

function EmployeeOpenInput, ^val
    optional out errorMessage, a  ;Returned error text
    endparams
    stack record
        ch, int
        errmsg, a128
    endrecord
proc

    try
    begin
        open(ch=0,i:i,"REPLICATOR_DATA:EMPLOYEE.ISM")
        clear errmsg
    end
    catch (ex, @Exception)
    begin
        errmsg = ex.Message
        clear ch
    end
    endtry

    if (^passed(errorMessage))
        errorMessage = errmsg

    freturn ch

endfunction

;*****************************************************************************
;;; <summary>
;;; Loads a unique key value into the respective fields in a record.
;;; </summary>
;;; <param name="aKeyValue">Unique key value.</param>
;;; <returns>Returns a record containig only the unique key segment data.</returns>

function EmployeeKeyToRecord, a

    required in aKeyValue, a
    endparams

    .include "EMPLOYEE" repository, stack record="employee", end

    stack record
        segPos, int
    endrecord

proc

    clear employee
    segPos = 1

    employee.emp_id = ^d(aKeyValue(segPos:8))
    segPos += 8

    freturn employee

endfunction

;*****************************************************************************
;;; <summary>
;;; Extract a key value from the segment fields in a record.
;;; This function behaves like %KEYVAL but without requiring an open channel.
;;; </summary>
;;; <param name="aRecord">Record containing key data</param>
;;; <returns>Returned key value.</returns>

function EmployeeKeyVal, ^val
    required in  aRecord, strEmployee
    required out aKeyVal, a
    required out aKeyLen, n
    endparams
    .align
    stack record
        pos,    int
        len,    int
        keyval, a255
    endrecord
proc
    clear keyval
    pos = 1
    len = 0

    ; Key segment 1 (Field)
    keyval(pos:8) = aRecord(1:8)
    len += 8

    aKeyVal = keyval(1,len)
    aKeyLen = len

    freturn true

endfunction

;*****************************************************************************
;;; <summary>
;;; Returns the key number of the first unique key.
;;; </summary>
;;; <returns>Returned key number.</returns>

function EmployeeKeyNum, ^val
proc
    freturn 0
endfunction

;*****************************************************************************
;;; <summary>
;;; 
;;; </summary>
;;; <returns></returns>

function EmployeeLength ,^val
proc
    freturn 300
endfunction

;*****************************************************************************
;;; <summary>
;;; 
;;; </summary>
;;; <param name="fileType"></param>
;;; <returns></returns>

function EmployeeType, ^val
    required out fileType, a
proc
    fileType = "DBL ISAM"
    freturn true
endfunction

;*****************************************************************************
;;; <summary>
;;; Return the number of columns in the Employee table
;;; </summary>
;;; <returns>Number of columns</returns>

function EmployeeCols ,^val
proc

    freturn 15

endfunction
