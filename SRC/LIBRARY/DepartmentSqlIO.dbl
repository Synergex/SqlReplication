;;*****************************************************************************
;;
;; File:        DepartmentSqlIO.dbl
;;
;; Description: Various functions that performs SQL I/O for DEPARTMENT
;;
;;*****************************************************************************
;; WARNING: THIS CODE WAS CODE GENERATED AND WILL BE OVERWRITTEN IF CODE
;;          GENERATION IS RE-EXECUTED FOR THIS PROJECT.
;;*****************************************************************************

import ReplicationLibrary
import Synergex.SynergyDE.Select

.ifndef strDepartment
.include "DEPARTMENT" repository, structure="strDepartment", end
.endc

;;*****************************************************************************
;;; <summary>
;;; Determines if the Department table exists in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the table exists, otherwise a number indicating the type of error.</returns>

function DepartmentExists, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        error       ,int    ;;Returned error number
        dberror     ,int    ;;Database error number
        cursor      ,int    ;;Database cursor
        length      ,int    ;;Length of a string
        table_name  ,a128   ;;Retrieved table name
        errtxt      ,a512   ;;Error message text
    endrecord

proc

    init local_data

    ;;Open a cursor for the SELECT statement

    if (%ssc_open(a_dbchn,cursor,"SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_NAME='Department'",SSQL_SELECT)==SSQL_FAILURE)
    begin
        error=-1
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    ;;Bind host variables to receive the data

    if (!error)
    begin
        if (%ssc_define(a_dbchn,cursor,1,table_name)==SSQL_FAILURE)
        begin
            error=-1
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variable"
        end
    end

    ;;Move data to host variables

    if (!error)
    begin
        if (%ssc_move(a_dbchn,cursor,1)==SSQL_NORMAL) then
        begin
            error = 1 ;; Table exists
        end
        else
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            begin
                errtxt="Failed to execute SQL Statement"
            end
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (!error)
            begin
                error=-1
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (error) then
            a_errtxt = errtxt
        else
            clear a_errtxt
    end

    freturn error

endfunction

;;*****************************************************************************
;;; <summary>
;;; Creates the Department table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentCreate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Create the database table and primary key constraint

    if (ok)
    begin
        sql = 'CREATE TABLE "Department" ('
        & + '"DeptId" VARCHAR(15) NOT NULL,'
        & + '"DeptName" VARCHAR(50) NOT NULL,'
        & + '"DeptManager" DECIMAL(6) NOT NULL,'
        & + 'CONSTRAINT PK_Department PRIMARY KEY CLUSTERED("DeptId" ASC)'
        & + ')'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Grant access permissions

    if (ok)
    begin
        sql = 'GRANT ALL ON "Department" TO PUBLIC'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
        xcall ThrowOnCommunicationError(dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Add alternate key indexes to the Department table if they do not exist.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    optional in  a_logchannel, n
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok                  ,boolean    ;;Return status
        dberror             ,int        ;;Database error number
        cursor              ,int        ;;Database cursor
        length              ,int        ;;Length of a string
        transaction         ,int        ;;Transaction in process
        keycount            ,int        ;;Total number of keys
        errtxt              ,a512       ;;Returned error message text
        now                 ,a20        ;;Current date and time
        sql                 ,string     ;;SQL statement
    endrecord

    .define writelog(x) writes(a_logchannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

proc
    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Set the SQL statement execution timeout to the bulk load value

    if (ok)
    begin
        now = %datetime
        writelog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to set database timeout"
        end
    end

    ;;Create index 1 (Department manager)

    if (ok && !%IndexExists(a_dbchn,"IX_Department_DeptManager",errtxt))
    begin
        now = %datetime
        writelog("  - Adding index IX_Department_DeptManager")

        sql = 'CREATE  INDEX IX_Department_DeptManager ON "Department"("DeptManager" ASC)'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end


    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;Set the database timeout back to the regular value

    now = %datetime
    writelog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
    if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
        nop

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
        xcall ThrowOnCommunicationError(dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Removes alternate key indexes from the Department table in the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentUnIndex, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        keycount    ,int        ;;Total number of keys
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc
    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Drop index 1 (Department manager)

    if (ok)
    begin
        sql = 'DROP INDEX IF EXISTS IX_Department_DeptManager ON "Department"'

        call open_cursor

        if (ok)
        begin
            call execute_cursor
            call close_cursor
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

open_cursor,

    if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to open cursor"
    end

    return

execute_cursor,

    if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
    begin
        ok = false
        if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
            errtxt="Failed to execute SQL statement"
        xcall ThrowOnCommunicationError(dberror,errtxt)
    end

    return

close_cursor,

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
        clear cursor
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Insert a row into the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record to be inserted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns 1 if the row was inserted, 2 to indicate the row already exists, or 0 if an error occurred.</returns>

function DepartmentInsert, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    .align
    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        sts         ,int        ;;Return status
        dberror     ,int        ;;Database error number
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Department ("
        & +              '"DeptId",'
        & +              '"DeptName",'
        & +              '"DeptManager"'
        & +              ") VALUES(:1,:2,:3)"
    endliteral

    static record
        department, strDepartment
    endrecord

    global common
        c1Department, i4, 0
    endcommon

proc

    init local_data
    ok = true
    sts = 1
    openAndBind = (c1Department == 0)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c1Department,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c1Department,3,
        &    department.dept_id,
        &    department.dept_name,
        &    department.dept_manager)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the row into the database

    if (ok)
    begin
        ;;Load the data into the bound record

        department = a_data

        ;;Clean up any alpha fields

        department.dept_name = %atrim(department.dept_name)+%char(0)

        ;;Clean up any decimal fields

        if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
            clear department.dept_manager

        ;;Clean up any date fields


        ;;Clean up any time fields


        ;;Assign data to any temporary time or user-defined timestamp fields


        ;;Assign values to temp fields for any fields with custom data types


        ;;Execute the INSERT statement

        if (%ssc_execute(a_dbchn,c1Department,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            sts = 0
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;If it's a "row exists" then return 2
                using dberror select
                (-2627),
                begin
                    ;;Duplicate key
                    errtxt = "Duplicate key detected in database!"
                    sts = 2
                end
                (),
                begin
                    nop
                end
                endusing
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
            end
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                sts = 0
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn sts

endfunction

;;*****************************************************************************
;;; <summary>
;;; Inserts multiple rows into the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Memory handle containing one or more rows to insert.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_exception">Memory handle to load exception data records into.</param>
;;; <param name="a_terminal">Terminal number channel to log errors on.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentInsertRows, ^val

    required in  a_dbchn,     i
    required in  a_commit_mode, i
    required in  a_data,      i
    optional out a_errtxt,    a
    optional out a_exception, i
    optional in  a_terminal,  i
    endparams

    .include "CONNECTDIR:ssql.def"

    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        dberror     ,int        ;;Database error number
        rows        ,int        ;;Number of rows to insert
        transaction ,int        ;;Transaction in progress
        length      ,int        ;;Length of a string
        ex_ms       ,int        ;;Size of exception array
        ex_mc       ,int        ;;Items in exception array
        continue    ,int        ;;Continue after an error
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, "INSERT INTO Department ("
        & +              '"DeptId",' ;#1
        & +              '"DeptName",' ;#2
        & +              '"DeptManager"' ;#3
        & +              ") VALUES(:1,:2,:3)"
    endliteral

    .include "DEPARTMENT" repository, structure="inpbuf", nofields, end
    .include "DEPARTMENT" repository, static record="department", end

    static record
        ,a1                         ;;In case there are no user timestamp, date or JJJJJJ date fields
    endrecord

    global common
        c2Department, i4
    endcommon

proc

    init local_data
    ok = true

    openAndBind = (c2Department == 0)

    if (^passed(a_exception)&&a_exception)
        clear a_exception

    ;;Figure out how many rows to insert

    rows = (%mem_proc(DM_GETSIZE,a_data)/^size(inpbuf))

    ;;If enabled, disable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"no")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to disable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;;Start a database transaction

    if (ok)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open a cursor for the INSERT statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c2Department,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be inserted

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c2Department,3,
        &    department.dept_id,
        &    department.dept_name,
        &    department.dept_manager)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Insert the rows into the database

    if (ok)
    begin
        data cnt, int
        for cnt from 1 thru rows
        begin
            ;;Load data into bound record

            department = ^m(inpbuf[cnt],a_data)

            ;;Clean up any alpha variables

            department.dept_name = %atrim(department.dept_name)+%char(0)

            ;;Clean up any decimal variables

            if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
                clear department.dept_manager

            ;;Clean up any date variables


            ;;Clean up any time variables


            ;;Assign any time or user-defined timestamp fields


        ;;Assign values to temp fields for any fields with custom data types


            ;;Execute the statement

            if (%ssc_execute(a_dbchn,c2Department,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to execute SQL statement"

                xcall ThrowOnCommunicationError(dberror,errtxt)

                clear continue

                ;;Are we logging errors?
                if (^passed(a_terminal)&&(a_terminal))
                begin
                    writes(a_terminal,errtxt(1:length))
                    continue=1
                end

                ;;Are we processing exceptions?
                if (^passed(a_exception))
                begin
                    if (ex_mc==ex_ms)
                    begin
                        if (!a_exception) then
                            a_exception = %mem_proc(DM_ALLOC|DM_STATIC,^size(inpbuf)*(ex_ms=EXCEPTION_BUFSZ))
                        else
                            a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*(ex_ms+=EXCEPTION_BUFSZ),a_exception)
                    end
                    ^m(inpbuf[ex_mc+=1],a_exception)=department
                    continue=1
                end

                if (continue) then
                    nextloop
                else
                begin
                    ok = false
                    exitloop
                end
            end
        end
    end

    ;;Commit or rollback the transaction

    if (transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If necessary, re-enable auto-commit

    if (a_commit_mode==1)
    begin
        if (%ssc_cmd(a_dbchn,,SSQL_ODBC_AUTOCOMMIT,"yes")!=SSQL_NORMAL)
        begin
            data dberrtxt, a1024
            xcall ssc_getemsg(a_dbchn,dberrtxt,length)
            errtxt = "Failed to enable auto-commit. Error was: " + dberrtxt(1,length)
            ok = false
        end
    end

    ;;If we're returning exceptions then resize the buffer to the correct size

    if (^passed(a_exception)&&a_exception)
        a_exception = %mem_proc(DM_RESIZ,^size(inpbuf)*ex_mc,a_exception)

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = %atrim(errtxt)+" [Database error "+%string(dberror)+"]"
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Updates a row in the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_data">Record containing data to update.</param>
;;; <param name="a_rows">Returned number of rows affected.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentUpdate, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_data,   a
    optional out a_rows,   i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;OK to continue
        openAndBind ,boolean    ;;Should we open the cursor and bind data this time?
        transaction ,boolean    ;;Transaction in progress
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        rows        ,int        ;;Number of rows updated
        errtxt      ,a512       ;;Error message text
    endrecord

    literal
        sql         ,a*, 'UPDATE Department SET '
        & +              '"DeptId"=:1,'
        & +              '"DeptName"=:2,'
        & +              '"DeptManager"=:3'
        & +              ' WHERE "DeptId"=:4  '
    endliteral

    static record
        department, strDepartment
    endrecord

    global common
        c3Department, i4
    endcommon
proc

    init local_data
    ok = true

    openAndBind = (c3Department == 0)

    if (^passed(a_rows))
        clear a_rows

    ;;Load the data into the bound record

    department = a_data

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction = true
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open a cursor for the UPDATE statement

    if (ok && openAndBind)
    begin
        if (%ssc_open(a_dbchn,c3Department,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Bind the host variables for data to be updated

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c3Department,3,
        &    department.dept_id,
        &    department.dept_name,
        &    department.dept_manager)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind variables"
        end
    end

    ;;Bind the host variables for the key segments / WHERE clause

    if (ok && openAndBind)
    begin
        if (%ssc_bind(a_dbchn,c3Department,1,department.dept_id)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to bind key variables"
        end
    end

    ;;Update the row in the database

    if (ok)
    begin
        ;;Clean up any alpha fields

        department.dept_name = %atrim(department.dept_name)+%char(0)

        ;;Clean up any decimal fields

        if ((!department.dept_manager)||(!%IsDecimalNoNegatives(department.dept_manager)))
            clear department.dept_manager

        ;;Clean up any date fields


        ;;Clean up any time fields


        ;;Assign any time and user-defined timestamp fields


        ;;Assign values to temp fields for any fields with custom data types


        if (%ssc_execute(a_dbchn,c3Department,SSQL_STANDARD,,rows)==SSQL_NORMAL) then
        begin
            if (^passed(a_rows))
                a_rows = rows
        end
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;Return error message

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes a row from the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_key">Unique key of row to be deleted.</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentDelete, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    required in  a_key,    a
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DEPARTMENT" repository, stack record="department"

    external function
        DepartmentKeyToRecord, a
    endexternal

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a512       ;;Error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Put the unique key value into the record

    department = %DepartmentKeyToRecord(a_key)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open a cursor for the DELETE statement

    if (ok)
    begin
        sql = 'DELETE FROM "Department" WHERE'
        & + ' "DeptId"=' + "'" + %atrim(department.dept_id) + "' "
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute the query

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes all rows from the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentClear, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in process
        errtxt      ,a512       ;;Returned error message text
        sql         ,string     ;;SQL statement
    endrecord

proc

    init local_data
    ok = true

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open cursor for the SQL statement

    if (ok)
    begin
        sql = 'TRUNCATE TABLE "Department"'
        if (%ssc_open(a_dbchn,cursor,(a)sql,SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute SQL statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to execute SQL statement"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Deletes the Department table from the database.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentDrop, ^val

    required in  a_dbchn,  i
    required in  a_commit_mode, i
    optional out a_errtxt, a
    endparams

    .include "CONNECTDIR:ssql.def"

    stack record local_data
        ok          ,boolean    ;;Return status
        dberror     ,int        ;;Database error number
        cursor      ,int        ;;Database cursor
        length      ,int        ;;Length of a string
        transaction ,int        ;;Transaction in progress
        errtxt      ,a512       ;;Returned error message text
    endrecord

proc

    init local_data
    ok = true

    ;;Close any open cursors

    xcall DepartmentClose(a_dbchn)

    ;;Start a database transaction

    if (a_commit_mode==3)
    begin
        if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
            transaction=1
        else
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to start transaction"
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Open cursor for DROP TABLE statement

    if (ok)
    begin
        if (%ssc_open(a_dbchn,cursor,"DROP TABLE Department",SSQL_NONSEL)==SSQL_FAILURE)
        begin
            ok = false
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                errtxt="Failed to open cursor"
        end
    end

    ;;Execute DROP TABLE statement

    if (ok)
    begin
        if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
        begin
            if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
            begin
                ;;Check if the error was that the table did not exist
                if (dberror==-3701) then
                    clear errtxt
                else
                    ok = false
            end
            else
            begin
                errtxt="Failed to execute SQL statement"
                ok = false
            end
            xcall ThrowOnCommunicationError(dberror,errtxt)
        end
    end

    ;;Close the database cursor

    if (cursor)
    begin
        if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
        begin
            if (ok)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;;Commit or rollback the transaction

    if ((a_commit_mode==3) && transaction)
    begin
        if (ok) then
        begin
            ;;Success, commit the transaction
            if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to commit transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
        else
        begin
            ;;There was an error, rollback the transaction
            if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to rollback transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end
    end

    ;;If there was an error message, return it to the calling routine

    if (^passed(a_errtxt))
    begin
        if (ok) then
            clear a_errtxt
        else
            a_errtxt = errtxt
    end

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Load all data from REPLICATOR_DATA:DEPARTMENT.ISM into the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <param name="a_logex">Log exception records?</param>
;;; <param name="a_terminal">Terminal channel to log errors on.</param>
;;; <param name="a_added">Total number of successful inserts.</param>
;;; <param name="a_failed">Total number of failed inserts.</param>
;;; <param name="a_progress">Report progress.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentLoad, ^val

    required in    a_dbchn,         i
    required in    a_commit_mode,   i
    optional out   a_errtxt,        a
    optional in    a_logex,	        i
    optional in    a_terminal,      i
    optional inout a_added,         n
    optional out   a_failed,        n
    optional in    a_progress,      n
    endparams

    .include "CONNECTDIR:ssql.def"
    .include "DEPARTMENT" repository, structure="inpbuf", end
    .include "DEPARTMENT" repository, stack record="tmprec", end

    .define BUFFER_ROWS     1000
    .define EXCEPTION_BUFSZ 100

    stack record local_data
        ok          ,boolean    ;;Return status
        firstRecord ,boolean    ;;Is this the first record?
        filechn     ,int        ;;Data file channel
        mh          ,D_HANDLE   ;;Memory handle containing data to insert
        ms          ,int        ;;Size of memory buffer in rows
        mc          ,int        ;;Memory buffer rows currently used
        ex_mh       ,D_HANDLE   ;;Memory buffer for exception records
        ex_mc       ,int        ;;Number of records in returned exception array
        ex_ch       ,int        ;;Exception log file channel
        attempted   ,int        ;;Rows being attempted
        done_records,int        ;;Records loaded
        max_records ,int        ;;Maximum records to load
        ttl_added   ,int        ;;Total rows added
        ttl_failed  ,int        ;;Total failed inserts
        errnum      ,int        ;;Error number
        errtxt      ,a512       ;;Error message text
    endrecord

proc

    init local_data
    ok = true

    ;;If we are logging exceptions, delete any existing exceptions file.
    if (^passed(a_logex) && a_logex)
    begin
        xcall delet("REPLICATOR_LOGDIR:department_data_exceptions.log")
    end

    ;;Open the data file associated with the structure

    if (!(filechn = %DepartmentOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    ;;Were we passed a max # records to load

    max_records = (^passed(a_added) && a_added > 0) ? a_added : 0
    done_records = 0

    if (ok)
    begin
        ;;Allocate memory buffer for the database rows

        mh = %mem_proc(DM_ALLOC,^size(inpbuf)*(ms=BUFFER_ROWS))

        ;;Read records from the input file

        firstRecord = true
        repeat
        begin
            ;;Get the next record from the input file
            try
            begin
                if (firstRecord) then
                begin
                    read(filechn,tmprec,^FIRST)
                    firstRecord = false
                end
                else
                begin
                    reads(filechn,tmprec)
                end
            end
            catch (ex, @EndOfFileException)
            begin
                exitloop
            end
            catch (ex, @Exception)
            begin
                ok = false
                errtxt = "Unexpected error while reading data file: " + ex.Message
                exitloop
            end
            endtry

            ;;Got one, load it into or buffer
            ^m(inpbuf[mc+=1],mh) = tmprec

            incr done_records

            ;;If the buffer is full, write it to the database
            if (mc==ms)
            begin
                call insert_data
            end

            if (max_records && (done_records == max_records))
            begin
                exitloop
            end
        end

        if (mc)
        begin
            mh = %mem_proc(DM_RESIZ,^size(inpbuf)*mc,mh)
            call insert_data
        end

        ;;Deallocate memory buffer

        mh = %mem_proc(DM_FREE,mh)

    end

    ;;Close the file

    if (filechn && %chopen(filechn))
        close filechn

    ;;Close the exceptions log file

    if (ex_ch && %chopen(ex_ch))
        close ex_ch

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

    ;;Return totals

    if (^passed(a_added))
        a_added = ttl_added
    if (^passed(a_failed))
        a_failed = ttl_failed

    freturn ok

insert_data,

    attempted = (%mem_proc(DM_GETSIZE,mh)/^size(inpbuf))

    if (%DepartmentInsertRows(a_dbchn,a_commit_mode,mh,errtxt,ex_mh,a_terminal))
    begin
        ;;Any exceptions?
        if (ex_mh) then
        begin
            ;;How many exceptions to log?
            ex_mc = (%mem_proc(DM_GETSIZE,ex_mh)/^size(inpbuf))
            ;;Update totals
            ttl_failed+=ex_mc
            ttl_added+=(attempted-ex_mc)
            ;;Are we logging exceptions?
            if (^passed(a_logex)&&a_logex) then
            begin
                data cnt, int
                ;;Open the log file
                if (!ex_ch)
                    open(ex_ch=0,o:s,"REPLICATOR_LOGDIR:department_data_exceptions.log")
                ;;Log the exceptions
                for cnt from 1 thru ex_mc
                    writes(ex_ch,^m(inpbuf[cnt],ex_mh))
                if (^passed(a_terminal)&&a_terminal)
                    writes(a_terminal,"Exceptions were logged to REPLICATOR_LOGDIR:department_data_exceptions.log")
            end
            else
            begin
                ;;No, report and error
                ok = false
            end
            ;;Release the exception buffer
            ex_mh=%mem_proc(DM_FREE,ex_mh)
        end
        else
        begin
            ;;No exceptions
            ttl_added += attempted
            if ^passed(a_terminal) && a_terminal && ^passed(a_progress) && a_progress
                writes(a_terminal," - " + %string(ttl_added) + " rows inserted")
        end
    end

    clear mc

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Bulk load data from REPLICATOR_DATA:DEPARTMENT.ISM into the Department table via a CSV file.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel.</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>
;;; <param name="a_localpath">Path to local export directory</param>
;;; <param name="a_remotepath">Remote export directory or URL</param>
;;; <param name="a_db_timeout">Database timeout in seconds.</param>
;;; <param name="a_bl_timeout">Bulk load timeout in seconds.</param>
;;; <param name="a_logchannel">Log file channel to log messages on.</param>
;;; <param name="a_records">Total number of records processed</param>
;;; <param name="a_exceptions">Total number of exception records detected</param>
;;; <param name="a_errtxt">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentBulkLoad, ^val

    required in  a_dbchn,      i
    required in  a_commit_mode, i
    required in  a_localpath,  string
    required in  a_server,     string
    required in  a_port,       string
    required in  a_db_timeout, n
    required in  a_bl_timeout, n
    optional in  a_logchannel, n
    optional in  a_ttchannel,  n
    optional out a_records,    n
    optional out a_exceptions, n
    optional out a_errtxt,     a
    endparams

    .include "CONNECTDIR:ssql.def"

     stack record local_data
        ok,                     boolean    ;;Return status
        transaction,            boolean
        cursorOpen,             boolean
        remoteBulkLoad,         boolean
        sql,                    string
        localCsvFile,           string
        localExceptionsFile,    string
        localExceptionsLog,     string
        remoteCsvFile,          string
        remoteExceptionsFile,   string
        remoteExceptionsLog,    string
        copyTarget,             string
        fileToLoad,             string
        errorFile,              string
        cursor,                 int
        length,                 int
        dberror,                int
        recordCount,            int	        ;;# records to load / loaded
        exceptionCount,         int
        errtxt,                 a512        ;;Error message text
        fsc,                    @FileServiceClient
        now,                    a20
    endrecord

    .define writelog(x) writes(a_logchannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)
    .define writett(x)  if ^passed(a_ttchannel) && a_ttchannel writes(a_ttchannel,"   - " + %string(^d(now(9:8)),"XX:XX:XX.XX ") + x)

proc

    init local_data
    ok = true

    ;;If we're doing a remote bulk load, create an instance of the FileService client and verify that we can access the FileService server

    if (remoteBulkLoad = ((a_server!=^null) && (a_server.nes." ")))
    begin
        fsc = new FileServiceClient(a_server,a_port)

        now = %datetime
        writelog("Verifying FileService connection")
        writett("Verifying FileService connection")

        if (!fsc.Ping(errtxt))
        begin
            now = %datetime
            writelog(errtxt = "No response from FileService, bulk upload cancelled")
            writett(errtxt = "No response from FileService, bulk upload cancelled")
            ok = false
        end
    end

    if (ok)
    begin
        ;;Determine temporary file names

        .ifdef OS_WINDOWS7
        localCsvFile = a_localpath + "\Department.csv"
        .endc
        .ifdef OS_UNIX
        localCsvFile = a_localpath + "/Department.csv"
        .endc
        .ifdef OS_VMS
        localCsvFile = a_localpath + "Department.csv"
        .endc
        localExceptionsFile  = localCsvFile + "_err"
        localExceptionsLog   = localExceptionsFile + ".Error.Txt"

        if (remoteBulkLoad)
        begin
            remoteCsvFile = "Department.csv"
            remoteExceptionsFile = remoteCsvFile + "_err"
            remoteExceptionsLog  = remoteExceptionsFile + ".Error.Txt"
        end

        ;;Make sure there are no files left over from previous operations

        ;;Delete local files

        now = %datetime
        writelog("Deleting local files")
        writett("Deleting local files")

        xcall delet(localCsvFile)
        xcall delet(localExceptionsFile)
        xcall delet(localExceptionsLog)

        ;;Delete remote files

        if (remoteBulkLoad)
        begin
            now = %datetime
            writelog("Deleting remote files")
            writett("Deleting remote files")

            fsc.Delete(remoteCsvFile)
            fsc.Delete(remoteExceptionsFile)
            fsc.Delete(remoteExceptionsLog)
        end

        ;;Were we asked to load a specific number of records?

        recordCount =  (^passed(a_records) && a_records > 0) ? a_records : 0

        ;;And export the data

        now = %datetime
        writelog("Exporting delimited file")
        writett("Exporting delimited file")

        ok = %DepartmentCsv(localCsvFile,recordCount,errtxt)
    end

    if (ok)
    begin
        ;;If necessary, upload the exported file to the database server

        if (remoteBulkLoad) then
        begin
            now = %datetime
            writelog("Uploading delimited file to database host")
            writett("Uploading delimited file to database host")
            ok = fsc.UploadChunked(localCsvFile,remoteCsvFile,320,fileToLoad,errtxt)
        end
        else
        begin
            fileToLoad  = localCsvFile
        end
    end

    if (ok)
    begin
        ;;Bulk load the database table

        ;;Start a database transaction

        if (a_commit_mode==3)
        begin
            now = %datetime
            writelog("Starting transaction")

            if (%ssc_commit(a_dbchn,SSQL_TXON)==SSQL_NORMAL) then
                transaction = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to start transaction"
                xcall ThrowOnCommunicationError(dberror,errtxt)
            end
        end

        ;;Open a cursor for the statement

        if (ok)
        begin
            now = %datetime
            writelog("Opening cursor")

            errorFile = fileToLoad + "_err"

            sql = "BULK INSERT Department FROM '" + fileToLoad + "' WITH (FIRSTROW=2,FIELDTERMINATOR='|',ROWTERMINATOR='\n', ERRORFILE='" + errorFile + "')"

            if (%ssc_open(a_dbchn,cursor,sql,SSQL_NONSEL,SSQL_STANDARD)==SSQL_NORMAL) then
                cursorOpen = true
            else
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to open cursor"
            end
        end

        ;;Set the SQL statement execution timeout to the bulk load value

        if (ok)
        begin
            now = %datetime
            writelog("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
            writett("Setting database timeout to " + %string(a_bl_timeout) + " seconds")
            if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_bl_timeout))==SSQL_FAILURE)
            begin
                ok = false
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to set database timeout"
            end
        end

        ;;Execute the statement

        if (ok)
        begin
            now = %datetime
            writelog("Executing BULK INSERT")
            writett("Executing BULK INSERT")
            if (%ssc_execute(a_dbchn,cursor,SSQL_STANDARD)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_NORMAL) then
                begin
                    xcall ThrowOnCommunicationError(dberror,errtxt)

                    now = %datetime
                    writelog("Bulk insert error")
                    writett("Bulk insert error")
                    using dberror select
                    (-4864),
                    begin
                        ;Bulk load data conversion error
                        now = %datetime
                        writelog("Data conversion errors were reported")
                        writett("Data conversion errors were reported")
                        clear dberror, errtxt
                        call GetExceptionDetails
                    end
                    (),
                    begin
                        errtxt = %string(dberror) + " " + errtxt
                        ok = false
                    end
                    endusing
                end
                else
                begin
                    errtxt="Failed to execute SQL statement"
                    ok = false
                end
            end

;            ;;Delete temporary files
;
;            ;;Delete local files
;
;            now = %datetime
;            writelog("Deleting local files")
;            writett(Deleting local files")
;
;            xcall delet(localCsvFile)
;            xcall delet(localExceptionsFile)
;            xcall delet(localExceptionsLog)
;
;            ;;Delete remote files
;
;            if (remoteBulkLoad)
;            begin
;                now = %datetime
;                writelog("Deleting remote files")
;                writett("Deleting remote files")
;                fsc.Delete(remoteCsvFile)
;                fsc.Delete(remoteExceptionsFile)
;                fsc.Delete(remoteExceptionsLog)
;            end
        end

        ;;Commit or rollback the transaction

        if ((a_commit_mode==3) && transaction)
        begin
            if (ok) then
            begin
                now = %datetime
                writelog("COMMIT")
                writett("COMMIT")
                if (%ssc_commit(a_dbchn,SSQL_TXOFF)==SSQL_FAILURE)
                begin
                    if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                        errtxt="Failed to commit transaction"
                    ok = false
                    xcall ThrowOnCommunicationError(dberror,errtxt)
                end
            end
            else
            begin
                ;;There was an error, rollback the transaction
                now = %datetime
                writelog("ROLLBACK")
                writett("ROLLBACK")
                if (%ssc_rollback(a_dbchn,SSQL_TXOFF) == SSQL_FAILURE)
                begin
                    ok = false
                    if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                        errtxt="Failed to rollback transaction"
                    xcall ThrowOnCommunicationError(dberror,errtxt)
                end
            end
        end

        ;;Set the database timeout back to the regular value

        now = %datetime
        writelog("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
        writett("Resetting database timeout to " + %string(a_db_timeout) + " seconds")
        if (%ssc_cmd(a_dbchn,,SSQL_TIMEOUT,%string(a_db_timeout))==SSQL_FAILURE)
            nop

        ;;Close the cursor

        if (cursorOpen)
        begin
            now = %datetime
            writelog("Closing cursor")
            writett("Closing cursor")
            if (%ssc_close(a_dbchn,cursor)==SSQL_FAILURE)
            begin
                if (%ssc_getemsg(a_dbchn,errtxt,length,,dberror)==SSQL_FAILURE)
                    errtxt="Failed to close cursor"
            end
        end
    end

    ;; Return the record count

    if (^passed(a_records))
        a_records = recordCount

    if (^passed(a_exceptions))
        a_exceptions = exceptionCount

    ;;Return the error text

    if (^passed(a_errtxt))
        a_errtxt = errtxt

      now = %datetime
      writelog("BULK ULOAD COMPLETE")

    freturn ok

GetExceptionDetails,

    ;;If we get here then the bulk load reported one or more "data conversion error" issues
    ;;There should be two files on the server

    now = %datetime
    writelog("Data conversion errors, processing exceptions")
    writett("Data conversion errors, processing exceptions")

    if (remoteBulkLoad) then
    begin
        data fileExists, boolean
        data tmpmsg, string

        if (fsc.Exists(remoteExceptionsFile,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;;Download the error file
                data exceptionRecords, [#]string

                now = %datetime
                writelog("Downloading remote exceptions data file")
                writett("Downloading remote exceptions data file")

                if (fsc.DownloadText(remoteExceptionsFile,exceptionRecords))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsFile)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    exceptionCount = exceptionRecords.Length

                    now = %datetime
                    writelog(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                    writett(%string(exceptionCount) + " items saved to " + localExceptionsFile)
                end
            end
            else
            begin
                ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions data file not found!")
                writett("Remote exceptions data file not found!")
            end
        end
        else
        begin
            ;;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
            writett("Failed to determine if remote exceptions data file exists. Error was " + tmpmsg)
        end

        ;;Now check for and retrieve the associated exceptions log

        if (fsc.Exists(remoteExceptionsLog,fileExists,tmpmsg)) then
        begin
            if (fileExists) then
            begin
                ;;Download the error file
                data exceptionRecords, [#]string

                now = %datetime
                writelog("Downloading remote exceptions log file")
                writett("Downloading remote exceptions log file")

                if (fsc.DownloadText(remoteExceptionsLog,exceptionRecords))
                begin
                    data ex_ch, int
                    data exceptionRecord, string

                    open(ex_ch=0,o:s,localExceptionsLog)

                    foreach exceptionRecord in exceptionRecords
                        writes(ex_ch,exceptionRecord)

                    close ex_ch

                    now = %datetime
                    writelog(%string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                    writelog(" - " + %string(exceptionRecords.Length) + " items saved to " + localExceptionsLog)
                end
            end
            else
            begin
                ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
                now = %datetime
                writelog("Remote exceptions file not found!")
                writett("Remote exceptions file not found!")
            end
        end
        else
        begin
            ;;Failed to determine if file exists
            now = %datetime
            writelog("Failed to determine if remote exceptions log file exists. Error was " + tmpmsg)
        end
    end
    else
    begin
        ;;Local bulk load

        if (File.Exists(localExceptionsFile)) then
        begin
            data ex_ch, int
            data tmprec, a65535
            open(ex_ch=0,i:s,localExceptionsFile)
            repeat
            begin
                reads(ex_ch,tmprec,eof)
                exceptionCount += 1
            end
eof,        close ex_ch
            now = %datetime
            writelog(%string(exceptionCount) + " exception items found in " + localExceptionsFile)
        end
        else
        begin
            ;;Error file does not exist! In theory this should not happen, because we got here due to "data conversion error" being reported
            now = %datetime
            writelog("Exceptions data file not found!")
        end
    end

    return

endfunction

;;*****************************************************************************
;;; <summary>
;;; Close cursors associated with the Department table.
;;; </summary>
;;; <param name="a_dbchn">Connected database channel</param>
;;; <param name="a_commit_mode">What commit mode are we using?</param>

subroutine DepartmentClose
    required in  a_dbchn, i
    endparams

    .include "CONNECTDIR:ssql.def"

    external common
        c1Department, i4
        c2Department, i4
        c3Department,  i4
    endcommon

proc

    if (c1Department)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c1Department))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c1Department
        end
        endtry
    end

    if (c2Department)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c2Department))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c2Department
        end
        endtry
    end

    if (c3Department)
    begin
        try
        begin
            if (%ssc_close(a_dbchn,c3Department))
                nop
        end
        catch (ex, @Exception)
        begin
            nop
        end
        finally
        begin
            clear c3Department
        end
        endtry
    end

    xreturn

endsubroutine

;;*****************************************************************************
;;; <summary>
;;; Exports REPLICATOR_DATA:DEPARTMENT.ISM to a CSV file.
;;; </summary>
;;; <param name="fileSpec">File to create</param>
;;; <param name="recordCount">Passed number of records to export, returned number of records exported.</param>
;;; <param name="errorMessage">Returned error text.</param>
;;; <returns>Returns true on success, otherwise false.</returns>

function DepartmentCsv, boolean
    required in    fileSpec, a
    optional inout recordCount, n
    optional out   errorMessage, a

    .include "DEPARTMENT" repository, record="department", end

    .define EXCEPTION_BUFSZ 100

    external function
        IsDecimalNo,                    boolean
        MakeDecimalForCsvNegatives,     a
        MakeDecimalForCsvNoNegatives,   a
        MakeTimeForCsv,                 a
    endexternal

    stack record local_data
.align
        ok,                             boolean     ;;Return status
.align
        filechn,                        int         ;;Data file channel
.align
        outchn,                         int         ;;CSV file channel
.align
        outrec,                         string      ;;A CSV file record
.align
        records,                        int         ;;Number of records exported
.align
        pos,                            int         ;;Position in a string
.align
        recordsMax,                     int         ;;Max # or records to export
.align
        errtxt,                         a512        ;;Error message text
    endrecord
proc

    ok = true
    clear records, errtxt

    ;;Were we given a max # or records to export?

    recordsMax = (^passed(recordCount) && recordCount > 0) ? recordCount : 0

    ;;Open the data file associated with the structure

    if (!(filechn=%DepartmentOpenInput))
    begin
        ok = false
        errtxt = "Failed to open data file!"
    end

    ;;Create the local CSV file

    if (ok)
    begin
        .ifdef OS_WINDOWS7
        open(outchn=0,o:s,fileSpec)
        .endc
        .ifdef OS_UNIX
        open(outchn=0,o,fileSpec)
        .endc
        .ifdef OS_VMS
        open(outchn=0,o,fileSpec,OPTIONS:"/stream")
        .endc

        ;;Add a row of column headers
        .ifdef OS_WINDOWS7
        writes(outchn,"DeptId|DeptName|DeptManager")
        .else
        puts(outchn,"DeptId|DeptName|DeptManager" + %char(13) + %char(10))
        .endc

        ;;Read and add data file records
        foreach department in new Select(new From(filechn,Q_NO_GRFA,0,department))
        begin
            ;;Make sure there are no | characters in the data
            while (pos = %instr(1,department,"|"))
            begin
                clear department(pos:1)
            end

            incr records

            if (recordsmax && (records > recordsMax))
            begin
                decr records
                exitloop
            end

            outrec = ""
            &    + (department.dept_id ? %atrim(department.dept_id) + "|" : "|")
            &    + (department.dept_name ? %atrim(department.dept_name) + "|" : "|")
            &    + (department.dept_manager ? %MakeDecimalForCsvNoNegatives(department.dept_manager) : "")

            .ifdef OS_WINDOWS7
            writes(outchn,outrec)
            .else
            puts(outchn,outrec + %char(13) + %char(10))
            .endc
        end
    end

eof,

    ;;Close the file
    if (filechn && %chopen(filechn))
    begin
        close filechn
    end

    ;;Close the CSV file
    if (outchn && %chopen(outchn))
    begin
        close outchn
    end

    ;;Return the record count
    if (^passed(recordCount))
        recordCount = records

    ;;Return the error text
    if (^passed(errorMessage))
        errorMessage = errtxt

    freturn ok

endfunction

;;*****************************************************************************
;;; <summary>
;;; Opens the REPLICATOR_DATA:DEPARTMENT.ISM for input.
;;; </summary>
;;; <param name="errorMessage">Returned error message.</param>
;;; <returns>Returns the channel number, or 0 if an error occured.</returns>

function DepartmentOpenInput, ^val
    optional out errorMessage, a  ;;Returned error text
    endparams
    stack record
        ch, int
        errmsg, a128
    endrecord
proc

    try
    begin
        open(ch=0,i:i,"REPLICATOR_DATA:DEPARTMENT.ISM")
        clear errmsg
    end
    catch (ex, @Exception)
    begin
        errmsg = ex.Message
        clear ch
    end
    endtry

    if (^passed(errorMessage))
        errorMessage = errmsg

    freturn ch

endfunction

;;*****************************************************************************
;;; <summary>
;;; Loads a unique key value into the respective fields in a record.
;;; </summary>
;;; <param name="aKeyValue">Unique key value.</param>
;;; <returns>Returns a record containig only the unique key segment data.</returns>

function DepartmentKeyToRecord, a

    required in aKeyValue, a
    endparams

    .include "DEPARTMENT" repository, stack record="department", end

    stack record
        segPos, int
    endrecord

proc

    clear department
    segPos = 1

    department.dept_id = aKeyValue(segPos:15)
    segPos += 15

    freturn department

endfunction


function DepartmentLength ,^val
proc
    freturn 71
endfunction

function DepartmentType, ^val
    required out fileType, a
proc
    fileType = "DBL ISAM"
    freturn true
endfunction
