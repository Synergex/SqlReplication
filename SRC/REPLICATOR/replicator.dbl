;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (SQL Replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import ReplicationLibrary
import System.Collections

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "DBLDIR:windows.def"
    .include "REPLICATOR_INCLUDE:SmtpMail.def"
.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction", end
.endc

.align
    record
        ok,                         boolean             ;;Main status
        noMoreInstructions,         boolean             ;;End of instruction file
        switchMode,                 boolean             ;;Switched from INSERT to UPDATE or vice versa
        switchDone,                 boolean             ;;Have we tried to switch modes before?
        bulkLoad,                   boolean             ;;Use bulk load?
        doCheckCommit,              boolean             ;;Do we need to check if it's time to commit?
        doForceCommit,              boolean             ;;Do we need to force a commit?
        nsptr,                      i4                  ;;Namespace pointer
        status,                     i4                  ;;General working status return
        rows,                       i4                  ;;Number of rows affected
        oldSleepTime,               i4                  ;;Previous sleep time value
        maxRowsToLoad,              i4                  ;;Maximum rows to load
        useTempTable,               i4                  ;;Use to TEMP table
        noLoadOnCreate,             i4                  ;;Do not load table after create
        functionName,               string              ;;External function to call
        keyValue,                   a256                ;;Key value of the current ISAM record
        keyLength,                  i4                  ;;Key length of the current ISAM record
        recordNumber,               d28                 ;;Record number of the current relative record
        dberrtxt,                   a1024               ;;Error text from a failed database call
        structure_data,             strStructureData    ;;Data stored for each structure
        uncommittedInstructions,    @ArrayList          ;;RFA's of any operation instructions pending commit
        unboxedRfa,                 a6                  ;;RFA of instruction record
        boxedRfa,                   @a                  ;;A boxed RFA value
    endrecord

    external function
        xsubr, ^val
    endexternal

proc

    if (ok = %ConfigureEnvironment)
    begin
        ;;If we're in batch commit mode then initialize a collection to store the RFA's of any pending operations
        if (Settings.CommitMode == DatabaseCommitMode.Batch)
        begin
            uncommittedInstructions = new ArrayList()
        end

        if (Settings.RunningOnTerminal)
        begin
            data system, i4
            data runtime, i4
            xcall envrn(system,runtime)
            using runtime select
            (101,104),
            begin
                xcall w_init(1,Settings.TerminalChannel,5)
                xcall w_caption(WC_SET,"SQL Replicator")
                xcall w_exit
            end
            endusing
        end

        ;;Main processing loop
        repeat
        begin
            ;;Get the next instruction from the queue
            repeat
            begin
                try
                begin
                    reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,GETRFA:unboxedRfa)
                    noMoreInstructions = false

                    ;;In batch commit mode, add the instructions RFA to the list of records to be deleted on commit
                    if (Settings.CommitMode == DatabaseCommitMode.Batch)
                    begin
                        uncommittedInstructions.Add((@a)unboxedRfa)
                    end

                    exitloop
                end
                catch (ex, @EndOfFileException)
                begin
                    noMoreInstructions = true
                    exitloop
                end
                catch (ex, @RecordLockedException)
                begin
                    sleep Settings.ErrorSleepTime
                    nextloop
                end
                catch (ex, @NetworkException); $ERR_NETPROB (320)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                endtry
            end

            if (noMoreInstructions) then
            begin
                ;;The queue is currently empty. If we're in batch commit mode then commit any outstanding changes
                if ((Settings.CommitMode == DatabaseCommitMode.Batch) && (Counters.BatchCounter > 0))
                begin
                    call CommitTransaction
                end

                ;;And sleep for a while before trying again
                sleep Settings.SleepTime

                ;;Reset to beginning of file
                repeat
                begin
                    try
                    begin
                        find(Settings.InstructionChannel,,^FIRST,LOCK:Q_NO_LOCK)
                        exitloop
                    end
                    catch (ex, @EndOfFileException); Instruction queue is empty
                    begin
                        exitloop
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile)
                            nextloop
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile)
                            nextloop
                    end
                    endtry
                end
            end
            else
            begin
                ;;Any action with a negative value has been co-opted to signify a shutdown request.
                if (instruction.action < 0)
                begin
                    ;;Restore the recorded action to it's original (positive) value
                    instruction.action = -instruction.action

                    repeat
                    begin
                        try
                        begin
                            write(Settings.InstructionChannel,instruction)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end

                    ;;And shutdown
                    Logger.Log("Shutdown requested")
                    xcall ReplicatorShutdown
                    stop
                end

                ;;We have an instruction to process

                doCheckCommit = false
                doForceCommit = false
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if     ((instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.INSERT_RELATIVE)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE)
                &    )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we failed to check the table for the file then we probably have a configuration problem
                    if (!status)
                    begin
                        Logger.ErrorLog("Abnormal replicator shutdown!")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                begin
                    call DoInsert
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                begin
                    call DoUpdate
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                begin
                    call DoDelete
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.INSERT_RELATIVE),
                begin
                    call DoInsertRelative
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                begin
                    call DoUpdateRelative
                    doCheckCommit = true
                end

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.ADD_INDEXES),
                begin
                    Logger.Log("Add indexes to table " + %atrim(instruction.structure_name))
                    call DoAddIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                begin
                    Logger.Log("Create table " + %atrim(instruction.structure_name))
                    call DoCreateTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                begin
                    Logger.Log("Load table " + %atrim(instruction.structure_name))
                    bulkLoad = false
                    maxRowsToLoad = 0
                    useTempTable = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                begin
                    if (bulkLoad = Settings.CanBulkLoad()) then
                    begin
                        Logger.Log("------------------------------------------------------------")
                        Logger.Log("Bulk load table " + %atrim(instruction.structure_name))
                    end
                    else
                    begin
                        Logger.Log("Bulk load requested but unavailable!")
                        Logger.Log("Load table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 0
                    useTempTable = 0
                    call DoLoadTable
                    bulkLoad = false
                    doForceCommit = true
                    Logger.Log("------------------------------------------------------------")
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000),
                begin
                    if (bulkLoad = Settings.CanBulkLoad()) then
                    begin
                        Logger.Log("Bulk load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    else
                    begin
                        Logger.Log("Bulk load 1000 records requested but unavailable!")
                        Logger.Log("Load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 1000
                    useTempTable = 0
                    call DoLoadTable
                    maxRowsToLoad = 0
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_TO_TEMP_TABLE),
                begin
                    Logger.Log("Bulk load table " + %atrim(instruction.structure_name) + "TEMP")
                    if (bulkLoad = Settings.CanBulkLoad()) then
                    begin
                        useTempTable = 1
                        call DoBulkLoadToTempTable
                        useTempTable = 0
                        doForceCommit = true
                    end
                    else
                    begin
                        Logger.Log("Bulk load unavailable!")
                    end
                end

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                begin
                    Logger.Log("Create and load table " + %atrim(instruction.structure_name))
                    call DoCreateAndLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                begin
                    Logger.Log("Exporting " + %atrim(instruction.structure_name) + " to delimited file")
                    call DoCreateCsv
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                begin
                    Logger.Log("Truncate table " + %atrim(instruction.structure_name))
                    call DoDeleteAllRows
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                begin
                    Logger.Log("Remove indexes from table " + %atrim(instruction.structure_name))
                    call DoDeleteIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                begin
                    Logger.Log("Delete table " + %atrim(instruction.structure_name))
                    call DoDeleteTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_TEMP_TABLE),
                begin
                    Logger.Log("Delete table " + %atrim(instruction.structure_name) + "TEMP")
                    useTempTable = 1
                    call DoDeleteTable
                    useTempTable = 0
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                begin
                    Logger.Log("Change processing interval")

                    oldSleepTime = Settings.SleepTime
    
                    try
                    begin
                        Settings.SleepTime = %integer(%atrim(instruction.record))
                        if (Settings.SleepTime >= 1) then
                        begin
                            Logger.Log("Interval changed from " + %string(oldSleepTime) + " to " + %string(Settings.SleepTime) + " seconds")
                        end
                        else
                        begin
                            Logger.ErrorLog("Invalid interval of " + %string(Settings.SleepTime) + " seconds requested")
                            Settings.SleepTime = oldSleepTime
                        end
                    end
                    catch (ex)
                    begin
                        Logger.ErrorLog("Invalid interval " + %atrim(instruction.record) + " requested")
                        Settings.SleepTime = oldSleepTime
                    end
                    endtry

                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end
                end

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    Logger.Log("Cycle log file")
                    Logger.CycleLog()

                    ;; Delete the "Cycle Log" instruction from the instructions 
                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    Logger.Log("Shutdown requested")

                    ;;Delete the "Shutdown" instruction from the queue
                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end

                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;If we're in batch commit mode, do we need to commit?
                if (Settings.CommitMode == DatabaseCommitMode.Batch) then
                begin
                    ;;In batch commit mode we don't delete instructions until the batch has been committed
                    try
                    begin
                        unlock Settings.InstructionChannel
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile) nop
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile) nop
                    end
                    endtry

                    ;;This logic may look a little "hokey", but there is a reason for it!
                    if ((doForceCommit && (Counters.BatchCounter+=1)) || (doCheckCommit && ((Counters.BatchCounter += 1) == Settings.CommitBatchRows)))
                    begin
                        call CommitTransaction
                    end
                end
                else
                begin
                    ;;Not in batch mode, delete the completed instruction now
                    try
                    begin
                        delete(Settings.InstructionChannel)
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile)
                        begin
                            ;;Re-read and lock the instruction record. What if THIS fails????
                            read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                            nextloop
                        end
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile)
                        begin
                            ;;Re-read and lock the instruction record. What if THIS fails????
                            read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                            nextloop
                        end
                    end
                    endtry
                end
            end
        end
    end

    ;;Close the database
    xcall DatabaseDisconnect

    ;;Release the namespace
    if (Settings.ChannelInfo)
    begin
        xcall nspc_close(Settings.ChannelInfo)
    end

    ;;Close the instructions file
    if (Settings.InstructionChannel && %chopen(Settings.InstructionChannel))
    begin
        close Settings.InstructionChannel
    end

    ;;All done
    stop

;;-----------------------------------------------------------------------------
;; Commit the current transaction and start a new one (only used in batch transaction mode)
;;
CommitTransaction,

    Logger.VerboseLog("Committing transaction with " + %string(Counters.BatchCounter) + " change(s)")

    if (%ssc_commit(Settings.DatabaseChannel,SSQL_TXON)==SSQL_NORMAL) then
    begin
        ;;Delete all of the associated instructions from the queue file.
        foreach boxedRfa in uncommittedInstructions
        begin
            unboxedRfa = (a)boxedRfa
            try
            begin
                read(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,RFA:unboxedRfa)
                delete(Settings.InstructionChannel)
            end
            catch (ex, @NetworkException); $ERR_NETPROB (320)
            begin
                if (%ReOpenQueueFile) nextloop
            end
            catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
            begin
                if (%ReOpenQueueFile) nextloop
            end
            catch (e, @Exception)
            begin
                ;;This can happen from time to time, because some "special"
                ;;instructions like "change interval" and "cycle log" are deleted
                ;;from the queue immediately even though the rfa has already been
                ;;recorded. Just ignore it.
                nop
            end
            endtry
        end

        uncommittedInstructions.Clear()

        Logger.VerboseLog("Start transaction")
        Counters.BatchCommits += 1
        Counters.BatchCounter = 0
    end
    else
    begin
        ;Batch commit failed
        data length = 0
        if (%ssc_getemsg(Settings.DatabaseChannel,dberrtxt,length)==SSQL_FAILURE) then
        begin
            dberrtxt="Batch commit failed"
        end
        else
        begin
            dberrtxt="Batch commit failed: " + dberrtxt(1:length)
        end
        Logger.ErrorLog(dberrtxt)
    end

    return

;;-----------------------------------------------------------------------------
;; Check if we have already opened this file in this process
;;
CheckFileTable,

    ;;If there is an entry for the file in our namespace then we're good to go

    if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin
        status = true
        return
    end

    Logger.VerboseLog("First instruction checks for table " + %atrim(instruction.structure_name))

    ;;Make sure the table exists in the database

    call CheckTable

    ;;If we failed verify the table then we have a serious problem!

    if (!status)
    begin
        Logger.ErrorLog("Failed to verify table status for structure " + %atrim(instruction.structure_name))
        return
    end

    ;;Get the record size of the file

    begin
        data doReturn, boolean, false

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Length"
            structure_data.structure_size = %xsubr(functionName)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true
        end
        endtry

        if (doReturn)
            return

        ;;Get the type of the file

        doReturn = false

        try
        begin
            functionName = %atrim(instruction.structure_name) + "Type"
            xcall xsubr(functionName,structure_data.structure_type)
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = false
        end
        endtry

        if (doReturn)
            return
    end

    using structure_data.structure_type select

    ("DBL ISAM"),
    begin
        ;;Get the key number of the first unique key. There should always be one, because without
        ;;one the constructor in the I/O hooks class would not activate replication for the file.
        functionName = %atrim(instruction.structure_name) + "KeyNum"
        structure_data.structure_keynum = %xsubr(functionName)

        ;;Report the key that will be used
        Logger.VerboseLog("Key " + %string(structure_data.structure_keynum) + " will be used to synchronize data")

        ;;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;;Record the new open file in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    ("RELATIVE"),
    begin
        ;;Report that record numbers will be used
        Logger.VerboseLog("Record numbers will be used to synchronize data")

        ;;Set the key number to -1 to prevent it being used accidentally
        structure_data.structure_keynum = -1

        ;;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;;Record the new open file in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    endusing

    return

;;-----------------------------------------------------------------------------
;; Find out if a table exists in the SQL database. If not create and load it.
;;
CheckTable,

    Logger.VerboseLog("Checking if table exists")

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,(i)(Settings.CommitMode),useTempTable,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return out of a try in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return out of a try in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (1),
    begin
        Logger.VerboseLog("Table exists")
    end
    (0),
    begin
        Logger.VerboseLog("Table not found!")
        call CreateTable
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt,^null)
    end
    endusing

    return

;-----------------------------------------------------------------------------
; Create and load a new table in the SQL database
; This code is only used when doing an initial check for a table because of
; a first replication instruction. Explicit CREATE_TABLE instructions are
; handled by DoCreateTable.
;
CreateTable,

    Logger.Log("Creating table")

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Create"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),(i)(Settings.DataCompressionMode),useTempTable,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        if (!noLoadOnCreate)
        begin
            ;;Now do an initial load of the data
            if (Settings.CanBulkLoad()) then
            begin
                call BulkLoadTable
            end
            else
            begin
                call LoadTable
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt,^null)
    end

    return

;-----------------------------------------------------------------------------
; Perform an initial load of a new table in the SQL database
;
LoadTable,

    Logger.Log("Load starting at " + %TimeNow)

    repeat
    begin
        clear status

        try
        begin
            data successCount, int, maxRowsToLoad
            data failCount, int, 0

            functionName = %atrim(instruction.structure_name) + "Load"

            if (Settings.RunningOnTerminal) then
            begin
                status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),dberrtxt,Settings.LogLoadExceptions,Settings.TerminalChannel,successCount,failCount,Settings.BulkLoadProgressReporting)
            end
            else
            begin
                status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),dberrtxt,Settings.LogLoadExceptions,,successCount,failCount)
            end

            if (status) then
            begin
                Logger.Log("Load complete at " + %TimeNow)
                Logger.Log(%string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
                Counters.Inserts += successCount
                Counters.Errors  += failCount
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        endtry
    end

    ;;Now add alternate key indexes
    if (ok && status)
    begin
        call DoAddIndexes
    end

    return

;-----------------------------------------------------------------------------
; Perform a bulk load of a table from a delimited text file.
;
BulkLoadTable,

    Logger.Log("Bulk load starting at " + %TimeNow)

    repeat
    begin
        clear status

        try
        begin
            data totalRows, int, maxRowsToLoad
            data failRows, int, 0

            functionName = %atrim(instruction.structure_name) + "BulkLoad"
            status = %xsubr(functionName,Settings.DatabaseChannel,(i)(Settings.CommitMode),Settings.LocalExportPath,Settings.FileServiceHost,Settings.FileServicePort,useTempTable,Settings.DatabaseTimeout,Settings.BulkLoadTimeout,Settings.BulkLoadBatchSize,Settings.LogFileChannel,Settings.TerminalChannel,totalRows,failRows,dberrtxt)

            if (status) then
            begin
                Logger.Log("Bulk load processed " + %string(totalRows) + " rows")
                Counters.Inserts += totalRows - failRows
                Counters.Errors  += failRows

                if (failRows)
                begin
                    Logger.WarningLog(%string(failRows) + " rows failed during BULK INSERT phase!")
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            exitloop
        end
        endtry
    end

    ;;If the bulk load worked, and we're in batch commit mode, commit the bulk
    ;;load before adding indexex. This will ensure that the bulk loaded data
    ;;will remain in the table even if errors occur during indexing.
    if (ok && status && Settings.CommitMode==DatabaseCommitMode.Batch)
    begin
        Counters.BatchCounter = Counters.Inserts
        call CommitTransaction
    end

    ;;Now add alternate key indexes
    if (ok && status && !useTempTable)
    begin
        call DoAddIndexes
    end

    return

;-----------------------------------------------------------------------------
; Add a new row (ISAM)
;
DoInsert,

    if (switchMode)
    begin
        switchMode = false
    end

    if (Settings.LogKeys) then
    begin
        functionName = %atrim(instruction.structure_name) + "KeyVal"
        status = %xsubr(functionName,instruction.record,keyValue,keyLength)
        Logger.VerboseLog("Insert " + %atrim(instruction.structure_name) + " key " + keyValue(1:keyLength))
    end
    else
    begin
        Logger.VerboseLog("Insert " + %atrim(instruction.structure_name))
    end

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,keyValue(1:keyLength))
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,keyValue(1:keyLength))
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (0),
    begin
        functionName = %atrim(instruction.structure_name) + "KeyVal"
        status = %xsubr(functionName,instruction.record,keyValue,keyLength)
        Logger.LogFunctionError(functionName,status,dberrtxt,keyValue(1:keyLength))
    end
    (1),
    begin
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog("Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog("Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

;-----------------------------------------------------------------------------
; Add a new row (RELATIVE)
;
DoInsertRelative,

    if (switchMode)
    begin
        Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end

    if (Settings.LogKeys) then
    begin
        data pos, i4, %instr(1,instruction.record,":")
        recordNumber = instruction.record(1:pos-1)
        instruction.record = instruction.record(pos+1:structure_data.structure_size)
        Logger.VerboseLog("Insert " + %atrim(instruction.structure_name) + " record " + %string(recordNumber))
    end
    else
    begin
        Logger.VerboseLog("Insert " + %atrim(instruction.structure_name))
    end

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),recordNumber,instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt,^null)
    end
    (1),
    begin
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog("Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog("Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdateRelative
        end
    end
    endusing

    return

;-----------------------------------------------------------------------------
; Update an existing row (ISAM)
;
DoUpdate,
    
    if (switchMode)
    begin
        switchMode = false
    end

    if (Settings.LogKeys) then
    begin
        functionName = %atrim(instruction.structure_name) + "KeyVal"
        status = %xsubr(functionName,instruction.record,keyValue,keyLength)
        Logger.VerboseLog("Update " + %atrim(instruction.structure_name) + " key " + keyValue(1:keyLength))
    end
    else
    begin
        Logger.VerboseLog("Update " + %atrim(instruction.structure_name))
    end

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,keyValue(1:keyLength))
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,keyValue(1:keyLength))
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        if (rows) then
        begin
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog("Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog("Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsert
            end
        end
    end
    else
    begin
        functionName = %atrim(instruction.structure_name) + "KeyVal"
        status = %xsubr(functionName,instruction.record,keyValue,keyLength)
        Logger.LogFunctionError(functionName,status,dberrtxt,keyValue(1:keyLength))
    end

    return

;-----------------------------------------------------------------------------
; Update an existing row (RELATIVE)
;
DoUpdateRelative,

    if (switchMode)
    begin
        switchMode = false
    end
    
    if (Settings.LogKeys) then
    begin
        data pos, i4, %instr(1,instruction.record,":")
        recordNumber = instruction.record(1:pos-1)
        instruction.record = instruction.record(pos+1:structure_data.structure_size)
        Logger.VerboseLog("Update " + %atrim(instruction.structure_name) + " record " + %string(recordNumber))
    end
    else
    begin
        Logger.VerboseLog("Update " + %atrim(instruction.structure_name))
    end

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),recordNumber,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    if (status) then
    begin
        if (rows) then
        begin
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog("Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog("Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsertRelative
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt,^null)
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Delete a row
    ;;
DoDelete,

    functionName = %atrim(instruction.structure_name) + "KeyVal"
    status = %xsubr(functionName,instruction.record,keyValue,keyLength)

    if (Settings.LogKeys) then
    begin
        Logger.VerboseLog("Delete " + %atrim(instruction.structure_name) + " key " + keyValue(1:keyLength))
    end
    else
    begin
        Logger.VerboseLog("Delete " + %atrim(instruction.structure_name))
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Delete"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),keyValue(1:keyLength),dberrtxt)
            if (status) then
            begin
                Counters.Deletes += 1
            end
            else
            begin
                Logger.VerboseLog(dberrtxt)
                Logger.LogFunctionError(functionName,status,dberrtxt,keyValue(1:keyLength))
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,keyValue(1:keyLength))
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,keyValue(1:keyLength))
            exitloop
        end
        endtry
    end

    return

;-----------------------------------------------------------------------------
; Create a new table
;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    Logger.VerboseLog("Checking if table exists")

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),useTempTable,dberrtxt)
            using status select
            (1),
            begin
                Logger.VerboseLog("Table exists!")
                exitloop
            end
            (0),
            begin
                Logger.VerboseLog("Creating table")

                repeat
                begin
                    try
                    begin
                        functionName = %atrim(instruction.structure_name) + "Create"
                        status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),(i)(Settings.DataCompressionMode),useTempTable,dberrtxt)
                        if (status) then
                        begin
                            if (Settings.CanSendEmail())
                            begin
                                xcall SendEmail("Replicator " + Settings.InstanceName + " created table " + %atrim(instruction.structure_name),^null,false,^null)
                            end
                        end
                        else
                        begin
                            Logger.LogFunctionError(functionName,status,dberrtxt,^null)
                        end
                    end
                    catch (ex, @DatabaseCommunicationException)
                    begin
                        ;;Attempt to disconnect from and re-connect to the database
                        if (%DatabaseReconnect(ex)) then
                        begin
                            ;;Re-connected, retry the previous operation
                            nextloop
                        end
                        else
                        begin
                            xcall ReplicatorShutdown
                        end
                    end
                    catch (ex, @SynException)
                    begin
                        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
                    end
                    endtry
                    exitloop
                end
                exitloop
            end
            (<0),
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
                exitloop
            end
            endusing
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            exitloop
        end
        endtry
    end

    return

;-----------------------------------------------------------------------------
; Load new data into existing table
;
DoLoadTable,

    ;;Do a full load of an existing table with new data

    Logger.VerboseLog("Checking if table exists")

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),useTempTable,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    using status select
    (1),
    begin
        Logger.VerboseLog("Table exists")

        ;;Delete any and all existing data before loading new data
        call DoDeleteAllRows

        if (bulkLoad) then
        begin
            call BulkLoadTable
        end
        else
        begin
            call LoadTable
        end
    end
    (0),
    begin
        Logger.VerboseLog("Table does not exist!")
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt,^null)
    end
    endusing

    return

;-----------------------------------------------------------------------------
; Create a new table and load new data into it
;
DoCreateAndLoadTable,
    
    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data
    call CheckTable

    return

;-----------------------------------------------------------------------------
; Export ISAM file to CSV file
;
DoCreateCsv,

    Logger.Log("Export starting at " + %TimeNow)

    try
    begin
        data csvFileSpec, a128, Settings.LocalExportPath
        functionName = %atrim(instruction.structure_name) + "Csv"
        status = %xsubr(functionName,csvFileSpec,dberrtxt)
        if (status) then
        begin
            Logger.VerboseLog("Export complete at " + %TimeNow)
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt,^null)
        end
    end
    catch (ex, @SynException)
    begin
        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
    end
    catch (ex, @Exception)
    begin
        ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
    end
    endtry

    return

;-----------------------------------------------------------------------------
; Delete all rows from an existing table
;
DoDeleteAllRows,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Clear"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),useTempTable,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog("Table truncated")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " truncated table " + %atrim(instruction.structure_name),^null,false,^null)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            exitloop
        end
        endtry
    end

    return

;-----------------------------------------------------------------------------
; Delete an existing table
;
DoDeleteTable,

    if (!useTempTable)
    begin
        ;;Is the file in the file table?
        if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
        begin
            ;Yes, remove it
            xcall nspc_delete(Settings.ChannelInfo,nsptr)
        end
    end

    repeat
    begin
        data doReturn, boolean, false
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Drop"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),useTempTable,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog("Table deleted")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " deleted table " + %atrim(instruction.structure_name),^null,false,^null)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            doReturn = true ;Can't return from a TRY in .NET
        end
        endtry

        if (doReturn)
            return
    end

    return

;-----------------------------------------------------------------------------
; Add alternate key indexes to a table (if they don't already exist)
;
DoAddIndexes,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Index"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),(i)(Settings.DatabaseTimeout),(i)(Settings.BulkLoadTimeout),(i)(Settings.DataCompressionMode),(i)(Settings.LogFileChannel),dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog("Indexes added")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " added indexes to table " + %atrim(instruction.structure_name),^null,false,^null)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog("Addining indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            exitloop
        end
        endtry
    end

    return

;-----------------------------------------------------------------------------
; Delete alternate key indexes from a table
;
DoDeleteIndexes,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "UnIndex"
            status = %xsubr(functionName,(i)(Settings.DatabaseChannel),(i)(Settings.CommitMode),dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog("Indexes removed")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " removed indexes from table " + %atrim(instruction.structure_name),^null,false,^null)
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt,^null)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect(ex)) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog("Removing indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message,^null)
            exitloop
        end
        catch (ex, @Exception)
        begin
            ok = Logger.LogFunctionFail(functionName,0,ex.Message,^null)
            exitloop
        end
        endtry
    end

    return

;;-----------------------------------------------------------------------------
;; Load new data into existing table
;;
DoBulkLoadToTempTable,

    call CheckTable

    using status select
    (0),
    begin
        ;Not found
        noLoadOnCreate = 1
        call CreateTable
        noLoadOnCreate = 0
    end
    (1),
    begin
        ;Exists
        call DoDeleteAllRows
    end
    endusing

    if (status==1)
    begin
        call BulkLoadTable
    end

    return

endmain
