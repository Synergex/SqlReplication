;;*****************************************************************************
;;
;; File:        replicator.dbl
;;
;; Type:        Application (SQL Replicator)
;;
;; Description: Replicates Synergy data file changes that have been recorded
;;              in the replucation log file to a SQL Server database.
;;
;;*****************************************************************************
;;
;; Copyright (c) 2008, Synergex International, Inc.
;; All rights reserved.
;;
;; Redistribution and use in source and binary forms, with or without
;; modification, are permitted provided that the following conditions are met:
;;
;; * Redistributions of source code must retain the above copyright notice,
;;   this list of conditions and the following disclaimer.
;;
;; * Redistributions in binary form must reproduce the above copyright notice,
;;   this list of conditions and the following disclaimer in the documentation
;;   and/or other materials provided with the distribution.
;;
;; THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
;; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
;; IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
;; ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
;; LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
;; CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
;; SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
;; INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
;; CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
;; ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
;; POSSIBILITY OF SUCH DAMAGE.
;;
;;*****************************************************************************

import replicator
import ReplicationLibrary
import System.Collections

main replicator

    .include "CONNECTDIR:ssql.def"
    .include "REPLICATOR_INCLUDE:SmtpMail.def"
.ifdef D_VMS
    .include "REPLICATION_VMS" repository, record="instruction", end
.else
    .include "REPLICATION" repository, record="instruction",end
.endc

.align
    record
        ok,                         boolean             ;;Main status
        noMoreInstructions,         boolean             ;;End of instruction file
        switchMode,                 boolean             ;;Switched from INSERT to UPDATE or vice versa
        switchDone,                 boolean             ;;Have we tried to switch modes before?
        bulkLoad,                   boolean             ;;Use bulk load?
        doCheckCommit,              boolean             ;;Do we need to check if it's time to commit?
        doForceCommit,              boolean             ;;Do we need to force a commit?
        nsptr,                      i4                  ;;Namespace pointer
        status,                     i4                  ;;General working status return
        rows,                       i4                  ;;Number of rows affected
        oldSleepTime,               i4                  ;;Previous sleep time value
        maxRowsToLoad,              i4                  ;;Maximum rows to load
        functionName,               string              ;;External function to call
        keyValue,                   a256                ;;Key value of the current ISAM record
        keyLength,                  i4                  ;;Key length of the current ISAM record
        recordNumber,               d28                 ;;Record number of the current relative record
        dberrtxt,                   a1024               ;;Error text from a failed database call
        structure_data,             strStructureData    ;;Data stored for each structure
        uncommittedInstructions,    @ArrayList          ;;RFA's of any operation instructions pending commit
        unboxedRfa,                 a6                  ;;RFA of instruction record
        boxedRfa,                   @a                  ;;A boxed RFA value
    endrecord

    external function
        xsubr,  ^val
    endexternal

proc

    if (ok = %ConfigureEnvironment)
    begin
        ;;If we're in batch commit mode then initialize a collection to store the RFA's of any pending operations
        if (Settings.CommitMode == DatabaseCommitMode.Batch)
        begin
            uncommittedInstructions = new ArrayList()
        end

        ;;Main processing loop
        repeat
        begin
            ;;Get the next instruction from the queue
            repeat
            begin
                try
                begin
                    reads(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,GETRFA:unboxedRfa)
                    noMoreInstructions = false

                    ;;In batch commit mode, add the instructions RFA to the list of records to be deleted on commit
                    if (Settings.CommitMode == DatabaseCommitMode.Batch)
                    begin
                        uncommittedInstructions.Add((@a)unboxedRfa)
                    end

                    exitloop
                end
                catch (ex, @EndOfFileException)
                begin
                    noMoreInstructions = true
                    exitloop
                end
                catch (ex, @RecordLockedException)
                begin
                    sleep Settings.ErrorSleepTime
                    nextloop
                end
                catch (ex, @NetworkException); $ERR_NETPROB (320)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                begin
                    if (%ReOpenQueueFile) nextloop
                end
                endtry
            end

            if (noMoreInstructions) then
            begin
                ;;The queue is currently empty. If we're in batch commit mode then commit any outstanding changes
                if ((Settings.CommitMode == DatabaseCommitMode.Batch) && (Counters.BatchCounter > 0))
                begin
                    call CommitTransaction
                end

                ;;And sleep for a while before trying again
                sleep Settings.SleepTime

                ;;Reset to beginning of file
                repeat
                begin
                    try
                    begin
                        find(Settings.InstructionChannel,,^FIRST,LOCK:Q_NO_LOCK)
                        exitloop
                    end
                    catch (ex, @EndOfFileException); Instruction queue is empty
                    begin
                        exitloop
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile)
                            nextloop
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile)
                            nextloop
                    end
                    endtry
                end
            end
            else
            begin
                ;;Any action with a negative value has been co-opted to signify a shutdown request.
                if (instruction.action < 0)
                begin
                    ;;Restore the recorded action to it's original (positive) value
                    instruction.action = -instruction.action

                    repeat
                    begin
                        try
                        begin
                            write(Settings.InstructionChannel,instruction)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end

                    ;;And shutdown
                    Logger.Log("Shutdown requested")
                    xcall ReplicatorShutdown
                    stop
                end

                ;;We have an instruction to process

                doCheckCommit = false
                doForceCommit = false
                switchDone = false

                ;;If this is a routine request (create/update/delete) then do
                ;;file and table checks to ensure we have the file open and the
                ;;database table exists
                if    ((instruction.action==(i)REPLICATION_INSTRUCTION.CREATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.DELETE_ROW)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.INSERT_RELATIVE)
                &    || (instruction.action==(i)REPLICATION_INSTRUCTION.UPDATE_RELATIVE)
                &    )
                begin
                    ;;Check if we already have the file open
                    call CheckFileTable

                    ;;If we failed to check the table for the file then we probably have a configuration problem
                    if (!status)
                    begin
                        Logger.ErrorLog("Abnormal replicator shutdown!")
                        exitloop
                    end
                end

                ;;Execute the instruction

                using (instruction.action) select

                ;;"Routine" processing requests

                (REPLICATION_INSTRUCTION.CREATE_ROW),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsert
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_ROW),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdate
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ROW),
                begin
                    Logger.VerboseLog("Delete row from table " + %atrim(instruction.structure_name))
                    call DoDelete
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.INSERT_RELATIVE),
                begin
                    Logger.VerboseLog("Insert row in table " + %atrim(instruction.structure_name))
                    call DoInsertRelative
                    doCheckCommit = true
                end

                (REPLICATION_INSTRUCTION.UPDATE_RELATIVE),
                begin
                    Logger.VerboseLog("Update row in table " + %atrim(instruction.structure_name))
                    call DoUpdateRelative
                    doCheckCommit = true
                end

                ;;"Special" processing requests

                (REPLICATION_INSTRUCTION.ADD_INDEXES),
                begin
                    Logger.Log("Add indexes to table " + %atrim(instruction.structure_name))
                    call DoAddIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_TABLE),
                begin
                    Logger.Log("Create table " + %atrim(instruction.structure_name))
                    call DoCreateTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.LOAD_TABLE),
                begin
                    Logger.Log("Load table " + %atrim(instruction.structure_name))
                    bulkLoad = false
                    maxRowsToLoad = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_TABLE),
                begin
                    if (bulkLoad = Settings.CanBulkLoad()) then
                        Logger.Log("Bulk load table " + %atrim(instruction.structure_name))
                    else
                    begin
                        Logger.Log("Bulk load requested but unavailable!")
                        Logger.Log("Load table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 0
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.BULK_LOAD_FIRST_1000),
                begin
                    if (bulkLoad = Settings.CanBulkLoad()) then
                    begin
                        Logger.Log("Bulk load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    else
                    begin
                        Logger.Log("Bulk load 1000 records requested but unavailable!")
                        Logger.Log("Load 1000 records to table " + %atrim(instruction.structure_name))
                    end
                    maxRowsToLoad = 1000
                    call DoLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_AND_LOAD_TABLE),
                begin
                    Logger.Log("Create and load table " + %atrim(instruction.structure_name))
                    call DoCreateAndLoadTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CREATE_CSV),
                begin
                    Logger.Log("Export table " + %atrim(instruction.structure_name) + " to delimited file")
                    call DoCreateCsv
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_ALL_ROWS),
                begin
                    Logger.Log("Truncate table " + %atrim(instruction.structure_name))
                    call DoDeleteAllRows
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_INDEXES),
                begin
                    Logger.Log("Remove indexes from table " + %atrim(instruction.structure_name))
                    call DoDeleteIndexes
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.DELETE_TABLE),
                begin
                    Logger.Log("Delete table " + %atrim(instruction.structure_name))
                    call DoDeleteTable
                    doForceCommit = true
                end

                (REPLICATION_INSTRUCTION.CHANGE_INTERVAL),
                begin
                    Logger.Log("Change processing interval")

                    oldSleepTime = Settings.SleepTime
    
                    try
                    begin
                        Settings.SleepTime = %integer(%atrim(instruction.record))
                        if (Settings.SleepTime >= 1) then
                        begin
                            Logger.Log(" - Interval changed from " + %string(oldSleepTime) + " to " + %string(Settings.SleepTime) + " seconds")
                        end
                        else
                        begin
                            Logger.ErrorLog(" - Invalid interval of " + %string(Settings.SleepTime) + " seconds requested")
                            Settings.SleepTime = oldSleepTime
                        end
                    end
                    catch (ex)
                    begin
                        Logger.ErrorLog(" - Invalid interval " + %atrim(instruction.record) + " requested")
                        Settings.SleepTime = oldSleepTime
                    end
                    endtry

                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end
                end

                (REPLICATION_INSTRUCTION.CYCLE_LOG),
                begin
                    Logger.Log("Cycle log file")
                    Logger.CycleLog()

                    ;; Delete the "Cycle Log" instruction from the instructions 
                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end
                end

                (REPLICATION_INSTRUCTION.SHUTDOWN),
                begin
                    Logger.Log("Shutdown requested")

                    ;;Delete the "Shutdown" instruction from the queue
                    repeat
                    begin
                        try
                        begin
                            delete(Settings.InstructionChannel)
                            exitloop
                        end
                        catch (ex, @NetworkException); $ERR_NETPROB (320)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                        begin
                            if (%ReOpenQueueFile)
                            begin
                                ;;Re-read and lock the instruction record. What if THIS fails????
                                read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                                nextloop
                            end
                        end
                        endtry
                    end

                    xcall ReplicatorShutdown
                    stop
                end

                endusing

                ;;If we're in batch commit mode, do we need to commit?
                if (Settings.CommitMode == DatabaseCommitMode.Batch) then
                begin
                    ;;In batch commit mode we don't delete instructions until the batch has been committed
                    try
                    begin
                        unlock Settings.InstructionChannel
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile) nop
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile) nop
                    end
                    endtry

                    ;;This logic may look a little "hokey", but there is a reason for it!
                    if ((doForceCommit && (Counters.BatchCounter+=1)) || (doCheckCommit && ((Counters.BatchCounter += 1) == Settings.CommitBatchRows)))
                    begin
                        call CommitTransaction
                    end
                end
                else
                begin
                    try
                    begin
                        delete(Settings.InstructionChannel)
                    end
                    catch (ex, @NetworkException); $ERR_NETPROB (320)
                    begin
                        if (%ReOpenQueueFile)
                        begin
                            ;;Re-read and lock the instruction record. What if THIS fails????
                            read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                            nextloop
                        end
                    end
                    catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
                    begin
                        if (%ReOpenQueueFile)
                        begin
                            ;;Re-read and lock the instruction record. What if THIS fails????
                            read(Settings.InstructionChannel,instruction,instruction.transaction_id)
                            nextloop
                        end
                    end
                    endtry
                end
            end
        end
    end

    ;;Close the database
    xcall DatabaseDisconnect

    ;;Release the namespace
    if (Settings.ChannelInfo)
    begin
        xcall nspc_close(Settings.ChannelInfo)
    end

    ;;Close the instructions file
    if (Settings.InstructionChannel && %chopen(Settings.InstructionChannel))
    begin
        close Settings.InstructionChannel
    end

    ;;All done
    stop

    ;;-----------------------------------------------------------------------------
    ;; Commit the current transaction and start a new one (only used in batch transaction mode)
    ;;
CommitTransaction,

    Logger.VerboseLog(" - Committing transaction with " + %string(Counters.BatchCounter) + " change(s)")

    if (%ssc_commit(Settings.DatabaseChannel,SSQL_TXON)==SSQL_NORMAL) then
    begin
        ;;Delete all of the associated instructions from the queue file.
        foreach boxedRfa in uncommittedInstructions
        begin
            unboxedRfa = (a)boxedRfa
            try
            begin
                read(Settings.InstructionChannel,instruction,,LOCK:Q_AUTO_LOCK,RFA:unboxedRfa)
                delete(Settings.InstructionChannel)
            end
            catch (ex, @NetworkException); $ERR_NETPROB (320)
            begin
                if (%ReOpenQueueFile) nextloop
            end
            catch (ex, @ServerNotRunningException); $ERR_NOSERVER (321)
            begin
                if (%ReOpenQueueFile) nextloop
            end
            catch (e, @Exception)
            begin
                ;;This can happen from time to time, because some "special"
                ;;instructions like "change interval" and "cycle log" are deleted
                ;;from the queue immediately even though the rfa has already been
                ;;recorded. Just ignore it.
                nop
            end
            endtry
        end

        uncommittedInstructions.Clear()

        Logger.VerboseLog(" - Start transaction")
        Counters.BatchCommits += 1
        Counters.BatchCounter = 0
    end
    else
    begin
        ;TODO: Commit failed - now what?


    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Check if we have already opened this file in this process
    ;;
CheckFileTable,

    ;;If there is an entry for the file in our namespace then we're good to go

    if (nsptr = %nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin
        status = true
        return
    end

    Logger.VerboseLog("First instruction checks for table " + %atrim(instruction.structure_name))

    ;;Make sure the table exists in the database

    call CheckTable

    ;;If we failed verify the table then we have a serious problem!

    if (!status)
    begin
        Logger.ErrorLog("Failed to verify table status for structure " + %atrim(instruction.structure_name))
        return
    end

    ;;Get the record size of the file
    functionName = %atrim(instruction.structure_name) + "Length"
    structure_data.structure_size = %xsubr(functionName)

    ;;Get the type of the file
    functionName = %atrim(instruction.structure_name) + "Type"
    xcall xsubr(functionName,structure_data.structure_type)

    using structure_data.structure_type select

    ("DBL ISAM"),
    begin
        ;;Get the key number of the first unique key. There should always be one, because without
        ;;one the constructor in the I/O hooks class would not activate replication for the file.
        functionName = %atrim(instruction.structure_name) + "KeyNum"
        structure_data.structure_keynum = %xsubr(functionName)

        ;;Report the key that will be used
        Logger.VerboseLog(" - Key " + %string(structure_data.structure_keynum) + " will be used to synchronize data")

        ;;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;;Record the table in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    ("RELATIVE"),
    begin
        ;;Report that record numbers will be used
        Logger.VerboseLog(" - Record numbers will be used to synchronize data")

        ;;Set the key number to -1 to prevent it being used accidentally
        structure_data.structure_keynum = -1

        ;;And save the structure name
        structure_data.structure_name = instruction.structure_name

        ;;Record the table in the namespace
        nsptr = %nspc_add(Settings.ChannelInfo,instruction.structure_name,structure_data)
    end

    endusing

    return

    ;;-----------------------------------------------------------------------------
    ;; Find out if a table exists in the SQL database. If not create and load it.
    ;;
CheckTable,

    Logger.VerboseLog(" - Checking if table exists")

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (1),
    begin
        Logger.VerboseLog(" - Table exists")
    end
    (0),
    begin
        Logger.VerboseLog(" - Table not found!")
        call CreateTable
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

    ;;-----------------------------------------------------------------------------
    ;; Create and load a new table in the SQL database
    ;; This code is only used when doing an initial check for a table because of
    ;; a first replication instruction. Explicit CREATE_TABLE instructions are
    ;; handled by DoCreateTable.
    ;;
CreateTable,

    Logger.Log(" - Creating table")

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Create"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    if (status) then
    begin
        ;;Now do an initial load of the data
        if (Settings.CanBulkLoad()) then
        begin
            call BulkLoadTable
        end
        else
        begin
            call LoadTable
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Perform an initial load of a new table in the SQL database
    ;;
LoadTable,

    Logger.Log(" - Load starting at " + %TimeNow)

    repeat
    begin
        clear status

        try
        begin
            data successCount,  int,maxRowsToLoad
            data failCount,     int,0

            functionName = %atrim(instruction.structure_name) + "Load"

            if (Settings.RunningOnTerminal) then
            begin
                status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt,Settings.LogLoadExceptions,Settings.TerminalChannel,successCount,failCount,Settings.BulkLoadProgressReporting)
            end
            else
            begin
                status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt,Settings.LogLoadExceptions,,successCount,failCount)
            end

            if (status) then
            begin
                Logger.Log(" - Load complete at " + %TimeNow)
                Logger.Log(" - " + %string(successCount) + " rows inserted, " + %string(failCount) + " rows failed.")
                Counters.Inserts += successCount
                Counters.Errors  += failCount
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    ;;Now add alternate key indexes
    if (ok && status)
    begin
        call DoAddIndexes
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Perform a bulk load of a table from a delimited text file.
    ;;
BulkLoadTable,

    Logger.Log(" - Bulk load starting at " + %TimeNow)

    repeat
    begin
        clear status

        try
        begin
            data totalRows, int,maxRowsToLoad
            data failRows,  int,0

            functionName = %atrim(instruction.structure_name) + "BulkLoad"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,Settings.LocalExportPath,Settings.FileServiceHost,Settings.FileServicePort,Settings.DatabaseTimeout,Settings.BulkLoadTimeout,Settings.LogFileChannel,Settings.TerminalChannel,totalRows,failRows,dberrtxt)

            if (status) then
            begin
                Logger.Log(" - Bulk load complete at " + %TimeNow)
                Logger.Log("   - " + %string(totalRows) + " records processed, " + %string(failRows) + " failed.")
                Counters.Inserts += totalRows - failRows
                Counters.Errors  += failRows
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    ;;Now add alternate key indexes
    if (ok && status)
    begin
        call DoAddIndexes
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Add a new row (ISAM)
    ;;
DoInsert,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
        end
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        Logger.VerboseLog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog(" - Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdate
        end
    end
    endusing

    return

    ;;-----------------------------------------------------------------------------
    ;; Add a new row (RELATIVE)
    ;;
DoInsertRelative,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Insert row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            data pos,   i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            Logger.VerboseLog(" - Record #: " + %string(recordNumber))
        end
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Insert"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,recordNumber,instruction.record(1,structure_data.structure_size),dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    (1),
    begin
        Logger.VerboseLog(" - Row inserted")
        Counters.Inserts += 1
    end
    (2),
    begin
        Logger.VerboseLog(" - Row exists, switching to UPDATE")
        status = 1
        if (switchDone) then
        begin
            Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
        end
        else
        begin
            switchMode = true
            call DoUpdateRelative
        end
    end
    endusing

    return

    ;;-----------------------------------------------------------------------------
    ;; Update an existing row (ISAM)
    ;;
DoUpdate,
    
    if (switchMode) then
    begin
        Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            functionName = %atrim(instruction.structure_name) + "KeyVal"
            status = %xsubr(functionName,instruction.record,keyValue,keyLength)
            Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
        end
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    if (status) then
    begin
        if (rows) then
        begin
            Logger.VerboseLog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog(" - Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsert
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Update an existing row (RELATIVE)
    ;;
DoUpdateRelative,

    if (switchMode) then
    begin
        Logger.VerboseLog(" - Update row in table " + %atrim(instruction.structure_name))
        switchMode = false
    end
    else
    begin
        if (Settings.LogKeys)
        begin
            data pos,   i4, %instr(1,instruction.record,":")
            recordNumber = instruction.record(1:pos-1)
            instruction.record = instruction.record(pos+1:structure_data.structure_size)
            Logger.VerboseLog(" - Record #: " + %string(recordNumber))
        end
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Update"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,recordNumber,instruction.record(1,structure_data.structure_size),rows,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    if (status) then
    begin
        if (rows) then
        begin
            Logger.VerboseLog(" - Row updated")
            Counters.Updates += 1
        end
        else
        begin
            Logger.VerboseLog(" - Row not found, switching to INSERT")
            status = 1
            if (switchDone) then
            begin
                Logger.ErrorLog(" - Too many INSERT/UPDATE mode switches!")
            end
            else
            begin
                switchMode = true
                call DoInsertRelative
            end
        end
    end
    else
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Delete a row
    ;;
DoDelete,

    functionName = %atrim(instruction.structure_name) + "KeyVal"
    status = %xsubr(functionName,instruction.record,keyValue,keyLength)

    if (Settings.LogKeys)
    begin
        Logger.VerboseLog(" - Key: " + keyValue(1:keyLength))
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Delete"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,keyValue(1:keyLength),dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Row deleted")
                Counters.Deletes += 1
            end
            else
            begin
                Logger.VerboseLog(" - " + dberrtxt)
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Create a new table
    ;;
DoCreateTable,

    ;;Create a new table (only)
    ;;If the table already exists, do nothing

    Logger.VerboseLog(" - Checking if table exists")

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            using status select
            (1),
            begin
                Logger.VerboseLog(" - Table exists!")
                exitloop
            end
            (0),
            begin
                Logger.VerboseLog(" - Creating table")

                repeat
                begin
                    try
                    begin
                        functionName = %atrim(instruction.structure_name) + "Create"
                        status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
                        if (status) then
                        begin
                            if (Settings.CanSendEmail())
                            begin
                                xcall SendEmail("Replicator " + Settings.InstanceName + " created table " + %atrim(instruction.structure_name))
                            end
                        end
                        else
                        begin
                            Logger.LogFunctionError(functionName,status,dberrtxt)
                        end
                    end
                    catch (ex, @DatabaseCommunicationException)
                    begin
                        ;;Attempt to disconnect from and re-connect to the database
                        if (%DatabaseReconnect) then
                        begin
                            ;;Re-connected, retry the previous operation
                            nextloop
                        end
                        else
                        begin
                            xcall ReplicatorShutdown
                        end
                    end
                    catch (ex, @SynException)
                    begin
                        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
                    end
                    endtry
                    exitloop
                end
                exitloop
            end
            (<0),
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
                exitloop
            end
            endusing
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Load new data into existing table
    ;;
DoLoadTable,

    ;;Do a full load of an existing table with new data

    Logger.VerboseLog(" - Checking if table exists")

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Exists"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    using status select
    (1),
    begin
        Logger.VerboseLog(" - Table exists")

        ;;Delete any and all existing data before loading new data
        call DoDeleteAllRows

        if (bulkLoad) then
        begin
            call BulkLoadTable
        end
        else
        begin
            call LoadTable
        end
    end
    (0),
    begin
        Logger.VerboseLog(" - Table does not exist!")
    end
    (<0),
    begin
        Logger.LogFunctionError(functionName,status,dberrtxt)
    end
    endusing

    return

    ;;-----------------------------------------------------------------------------
    ;; Create a new table and load new data into it
    ;;
DoCreateAndLoadTable,
    
    ;;Create a new table, do nothing if the table already exists
    ;;We create the table, then do a full load of data
    call CheckTable

    return

    ;;-----------------------------------------------------------------------------
    ;; Export ISAM file to CSV file
    ;;
DoCreateCsv,

    Logger.Log(" - Export starting at " + %TimeNow)

    try
    begin
        data csvFileSpec,   a128,   Settings.LocalExportPath
        functionName = %atrim(instruction.structure_name) + "Csv"
        status = %xsubr(functionName,csvFileSpec,dberrtxt)
        if (status) then
        begin
            Logger.VerboseLog(" - Export complete at " + %TimeNow)
        end
        else
        begin
            Logger.LogFunctionError(functionName,status,dberrtxt)
        end
    end
    catch (ex, @SynException)
    begin
        ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
    end
    endtry

    return

    ;;-----------------------------------------------------------------------------
    ;; Delete all rows from an existing table
    ;;
DoDeleteAllRows,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Clear"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Table truncated")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " truncated table " + %atrim(instruction.structure_name))
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Delete an existing table
    ;;
DoDeleteTable,

    ;;Is the table recorded in the list of open tables?
    if (nsptr=%nspc_find(Settings.ChannelInfo,instruction.structure_name,structure_data))
    begin
        ;Yes, remove it
        xcall nspc_delete(Settings.ChannelInfo,nsptr)
    end

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Drop"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Table deleted")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " deleted table " + %atrim(instruction.structure_name))
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            return
        end
        endtry
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Add alternate key indexes to a table (if they don't already exist)
    ;;
DoAddIndexes,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "Index"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,Settings.DatabaseTimeout,Settings.BulkLoadTimeout,Settings.LogFileChannel,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Indexes added")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " added indexes to table " + %atrim(instruction.structure_name))
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Addining indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

    ;;-----------------------------------------------------------------------------
    ;; Delete alternate key indexes from a table
    ;;
DoDeleteIndexes,

    repeat
    begin
        try
        begin
            functionName = %atrim(instruction.structure_name) + "UnIndex"
            status = %xsubr(functionName,Settings.DatabaseChannel,Settings.CommitMode,dberrtxt)
            if (status) then
            begin
                Logger.VerboseLog(" - Indexes removed")

                if (Settings.CanSendEmail())
                begin
                    xcall SendEmail("Replicator " + Settings.InstanceName + " removed indexes from table " + %atrim(instruction.structure_name))
                end
            end
            else
            begin
                Logger.LogFunctionError(functionName,status,dberrtxt)
            end
            exitloop
        end
        catch (ex, @DatabaseCommunicationException)
        begin
            ;;Attempt to disconnect from and re-connect to the database
            if (%DatabaseReconnect) then
            begin
                ;;Re-connected, retry the previous operation
                nextloop
            end
            else
            begin
                xcall ReplicatorShutdown
            end
        end
        catch (ex, @RoutineNotFound)
        begin
            Logger.VerboseLog(" - Removing indexes is not enabled for this table.")
            exitloop
        end
        catch (ex, @SynException)
        begin
            ok = Logger.LogFunctionFail(functionName,ex.Errno,ex.Message)
            exitloop
        end
        endtry
    end

    return

endmain
